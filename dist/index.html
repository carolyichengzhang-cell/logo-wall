<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Logo å¢™ç”Ÿæˆå™¨</title>
  <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/exceljs@4.4.0/dist/exceljs.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/file-saver@2.0.5/dist/FileSaver.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/pptxgenjs@3.12.0/dist/pptxgen.bundle.js"></script>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: #f0f2f5;
      min-height: 100vh;
      color: #333;
    }

    .header {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      padding: 36px 20px;
      text-align: center;
      color: #fff;
    }
    .header h1 { font-size: 2rem; font-weight: 700; margin-bottom: 6px; }
    .header p { font-size: 0.95rem; opacity: 0.85; }

    .container { max-width: 1200px; margin: 0 auto; padding: 28px 20px; }

    /* Tabs */
    .tabs {
      display: flex;
      gap: 0;
      margin-bottom: 24px;
      background: #fff;
      border-radius: 12px;
      overflow: hidden;
      box-shadow: 0 2px 8px rgba(0,0,0,0.06);
    }
    .tab-btn {
      flex: 1;
      padding: 14px;
      border: none;
      background: #fff;
      font-size: 0.95rem;
      font-weight: 600;
      color: #888;
      cursor: pointer;
      transition: all 0.2s;
      border-bottom: 3px solid transparent;
    }
    .tab-btn.active {
      color: #667eea;
      border-bottom-color: #667eea;
      background: #f8f9ff;
    }

    .tab-content { display: none; }
    .tab-content.active { display: block; }

    /* é€šç”¨å¡ç‰‡ */
    .card {
      background: #fff;
      border-radius: 14px;
      padding: 28px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.05);
      margin-bottom: 24px;
    }
    .card h3 { font-size: 1rem; font-weight: 600; margin-bottom: 16px; color: #444; }

    /* ä¸Šä¼ åŒºåŸŸ */
    .upload-area {
      border: 2px dashed #c4c9d4;
      border-radius: 12px;
      padding: 44px 20px;
      text-align: center;
      cursor: pointer;
      transition: all 0.3s;
      background: #fafbfc;
    }
    .upload-area:hover, .upload-area.dragover {
      border-color: #667eea;
      background: #f0f1ff;
    }
    .upload-area svg { width: 42px; height: 42px; color: #667eea; margin-bottom: 12px; }
    .upload-area h3 { font-size: 1.05rem; margin-bottom: 4px; color: #444; }
    .upload-area p { font-size: 0.85rem; color: #999; }
    .upload-area input { display: none; }

    /* æˆªå›¾è£å‰ªæ¨¡å¼ */
    .crop-workspace {
      display: none;
      margin-top: 20px;
    }
    .crop-workspace.visible { display: block; }

    .crop-canvas-container {
      position: relative;
      overflow: hidden;
      border: 1px solid #e0e0e0;
      border-radius: 10px;
      background: #f9f9f9;
      cursor: crosshair;
      user-select: none;
      -webkit-user-select: none;
    }
    .crop-canvas-container img {
      display: block;
      max-width: 100%;
      -webkit-user-drag: none;
      user-select: none;
      pointer-events: none;
    }

    .crop-selection-overlay {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      z-index: 10;
    }

    .crop-rect {
      position: absolute;
      border: 2px dashed #667eea;
      background: rgba(102,126,234,0.15);
      pointer-events: none;
      z-index: 11;
      display: none;
    }

    .crop-instructions {
      margin: 12px 0;
      padding: 12px 16px;
      background: #fff8e6;
      border-radius: 8px;
      font-size: 0.88rem;
      color: #8a6d00;
      line-height: 1.6;
    }

    /* è£å‰ªåˆ—è¡¨ */
    .crop-list {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
      gap: 16px;
      margin-top: 16px;
    }
    .crop-item {
      background: #fafbfc;
      border: 1px solid #eee;
      border-radius: 10px;
      padding: 12px;
      text-align: center;
    }
    .crop-item img {
      width: 72px;
      height: 72px;
      object-fit: contain;
      border-radius: 14px;
      margin-bottom: 8px;
      background: #fff;
      box-shadow: 0 1px 4px rgba(0,0,0,0.08);
    }
    .crop-item input {
      width: 100%;
      padding: 6px 10px;
      border: 1px solid #ddd;
      border-radius: 8px;
      font-size: 0.88rem;
      text-align: center;
      outline: none;
    }
    .crop-item input:focus { border-color: #667eea; }
    .crop-item select {
      width: 100%;
      padding: 5px 8px;
      border: 1px solid #ddd;
      border-radius: 8px;
      font-size: 0.82rem;
      text-align: center;
      outline: none;
      color: #667eea;
      background: #fff;
      cursor: pointer;
      margin-top: 4px;
    }
    .crop-item select:focus { border-color: #667eea; }
    .crop-item .category-group {
      display: flex;
      gap: 4px;
      margin-top: 4px;
    }
    .crop-item .category-group select {
      flex: 1;
      margin-top: 0;
      font-size: 0.78rem;
      padding: 4px 4px;
    }
    .category-tag {
      display: inline-block;
      font-size: 0.72rem;
      padding: 2px 6px;
      border-radius: 4px;
      margin: 1px;
    }
    .category-tag.major {
      background: #667eea22;
      color: #667eea;
    }
    .category-tag.minor {
      background: #764ba222;
      color: #764ba2;
    }
    .crop-item .crop-item-actions {
      margin-top: 6px;
    }
    .crop-item .remove-crop {
      background: none;
      border: none;
      color: #ff4d4f;
      cursor: pointer;
      font-size: 0.82rem;
    }
    .crop-item .ocr-status {
      font-size: 0.78rem;
      color: #667eea;
      margin-top: 4px;
    }

    /* æ‰¹é‡è®¾ç½®é¢æ¿ */
    .batch-settings {
      background: linear-gradient(135deg, #f8f9ff 0%, #f0f1ff 100%);
      border: 2px solid #e0e3ff;
      border-radius: 14px;
      padding: 20px 24px;
      margin-bottom: 20px;
      box-shadow: 0 2px 10px rgba(102,126,234,0.08);
    }
    .batch-settings-title {
      font-size: 0.95rem;
      font-weight: 700;
      color: #444;
      margin-bottom: 14px;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .batch-settings-title::before {
      content: 'âš™ï¸';
      font-size: 1.1rem;
    }
    .batch-settings-row {
      display: flex;
      align-items: center;
      gap: 16px;
      margin-bottom: 12px;
      flex-wrap: wrap;
    }
    .batch-settings-row:last-child { margin-bottom: 0; }
    .batch-settings-row label {
      font-weight: 600;
      font-size: 0.9rem;
      color: #555;
      white-space: nowrap;
      min-width: 70px;
    }
    .product-options, .region-options {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }
    .product-btn, .region-btn {
      padding: 6px 16px;
      border: 2px solid #ddd;
      border-radius: 20px;
      background: #fff;
      font-size: 0.85rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
      color: #666;
    }
    .product-btn:hover, .region-btn:hover { border-color: #667eea; color: #667eea; }
    .product-btn.active {
      background: linear-gradient(135deg, #667eea, #764ba2);
      color: #fff;
      border-color: transparent;
    }
    .region-btn.active {
      background: linear-gradient(135deg, #52c41a, #389e0d);
      color: #fff;
      border-color: transparent;
    }

    /* äº§å“/åœ°åŒºæ ‡ç­¾ */
    .tag-group {
      display: flex;
      gap: 4px;
      margin-top: 4px;
      flex-wrap: wrap;
      justify-content: center;
    }
    .tag-product, .tag-region {
      display: inline-block;
      padding: 2px 8px;
      border-radius: 10px;
      font-size: 0.72rem;
      font-weight: 600;
    }
    .tag-product {
      background: #667eea22;
      color: #667eea;
    }
    .tag-region {
      background: #52c41a22;
      color: #389e0d;
    }
    .crop-item .region-select {
      width: 100%;
      padding: 5px 8px;
      border: 1px solid #ddd;
      border-radius: 6px;
      font-size: 0.78rem;
      margin-top: 4px;
      cursor: pointer;
    }

    /* æ¨¡å¼äºŒï¼šç›´æ¥ä¸Šä¼ å¤šä¸ªLogo */
    .direct-upload-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
      gap: 14px;
      margin-top: 16px;
    }
    .direct-item {
      background: #fafbfc;
      border: 1px solid #eee;
      border-radius: 10px;
      padding: 12px;
      text-align: center;
    }
    .direct-item img {
      width: 64px;
      height: 64px;
      object-fit: contain;
      border-radius: 12px;
      margin-bottom: 8px;
      background: #fff;
      box-shadow: 0 1px 4px rgba(0,0,0,0.08);
    }
    .direct-item input {
      width: 100%;
      padding: 5px 8px;
      border: 1px solid #ddd;
      border-radius: 8px;
      font-size: 0.85rem;
      text-align: center;
      outline: none;
    }
    .direct-item input:focus { border-color: #667eea; }
    .direct-item .remove-direct {
      background: none;
      border: none;
      color: #ff4d4f;
      cursor: pointer;
      font-size: 0.82rem;
      margin-top: 4px;
    }

    /* ç”ŸæˆæŒ‰é’® */
    .generate-bar {
      text-align: center;
      margin: 24px 0;
      display: none;
    }
    .generate-bar.visible { display: block; }

    .btn {
      padding: 11px 28px;
      border: none;
      border-radius: 10px;
      font-size: 0.95rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
    }
    .btn-primary {
      background: linear-gradient(135deg, #667eea, #764ba2);
      color: #fff;
    }
    .btn-primary:hover { opacity: 0.9; transform: translateY(-1px); }
    .btn-danger { background: #ff4d4f; color: #fff; margin-left: 10px; }
    .btn-secondary { background: #eee; color: #555; margin-left: 10px; }

    /* Logo å¢™å±•ç¤º */
    .wall-section { display: none; }
    .wall-section.visible { display: block; }

    .wall-toolbar {
      background: #fff;
      border-radius: 14px;
      padding: 18px 24px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.05);
      margin-bottom: 20px;
      display: flex;
      flex-wrap: wrap;
      gap: 18px;
      align-items: center;
    }
    .wall-toolbar label {
      font-size: 0.88rem;
      font-weight: 500;
      color: #555;
      display: flex;
      align-items: center;
      gap: 6px;
    }
    .wall-toolbar select,
    .wall-toolbar input[type="range"] {
      border: 1px solid #ddd;
      border-radius: 8px;
      padding: 5px 8px;
      font-size: 0.88rem;
      outline: none;
    }
    .wall-toolbar input[type="range"] { width: 110px; }
    .wall-toolbar input[type="color"] {
      width: 32px; height: 32px; padding: 2px;
      border: 1px solid #ddd; border-radius: 8px; cursor: pointer;
    }
    .wall-toolbar-actions {
      margin-left: auto;
      display: flex;
      gap: 8px;
    }

    .logo-wall-wrapper {
      border-radius: 14px;
      overflow: hidden;
      box-shadow: 0 2px 10px rgba(0,0,0,0.05);
    }

    .logo-wall {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
      gap: 28px;
      padding: 40px;
      background: #fff;
      transition: all 0.3s;
    }

    .logo-wall.layout-flex {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      align-items: center;
    }

    .logo-wall.layout-rows {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      align-items: stretch;
    }

    .logo-entry {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 18px 12px;
      border-radius: 12px;
      transition: all 0.3s;
    }
    .logo-entry:hover { transform: translateY(-3px); }

    .logo-entry img {
      width: 64px;
      height: 64px;
      object-fit: contain;
      border-radius: 14px;
      margin-bottom: 10px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.08);
    }

    .logo-entry .logo-name {
      font-size: 0.82rem;
      color: #555;
      text-align: center;
      font-weight: 500;
      max-width: 120px;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .logo-entry .logo-category {
      font-size: 0.72rem;
      color: #667eea;
      text-align: center;
      max-width: 120px;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      margin-top: 2px;
    }
    .logo-entry .logo-subcategory {
      font-size: 0.68rem;
      color: #764ba2;
      text-align: center;
      max-width: 120px;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      margin-top: 1px;
    }

    .logo-wall.hide-names .logo-entry .logo-name { display: none; }
    .logo-wall.hide-names .logo-entry .logo-category { display: none; }
    .logo-wall.hide-names .logo-entry .logo-subcategory { display: none; }

    .logo-wall.grayscale .logo-entry img { filter: grayscale(100%); transition: filter 0.3s; }
    .logo-wall.grayscale .logo-entry:hover img { filter: grayscale(0%); }

    @media (max-width: 768px) {
      .header h1 { font-size: 1.5rem; }
      .card { padding: 18px; }
      .logo-wall { padding: 20px; gap: 16px; }
      .wall-toolbar { padding: 14px; gap: 10px; }
      .wall-toolbar-actions { margin-left: 0; width: 100%; }
      .crop-list { grid-template-columns: repeat(auto-fill, minmax(140px, 1fr)); }
      .library-grid { grid-template-columns: repeat(auto-fill, minmax(130px, 1fr)); }
    }

    /* Logo åº“ */
    .library-filter {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-bottom: 18px;
    }
    .filter-tag {
      padding: 6px 16px;
      border-radius: 20px;
      font-size: 0.85rem;
      cursor: pointer;
      border: 1px solid #e0e0e0;
      background: #fff;
      color: #666;
      transition: all 0.2s;
      user-select: none;
    }
    .filter-tag:hover { border-color: #667eea; color: #667eea; }
    .filter-tag.active {
      background: linear-gradient(135deg, #667eea, #764ba2);
      color: #fff;
      border-color: transparent;
    }
    .filter-tag .tag-count {
      font-size: 0.75rem;
      opacity: 0.8;
      margin-left: 4px;
    }

    .library-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(160px, 1fr));
      gap: 14px;
    }
    .library-empty {
      grid-column: 1/-1;
      text-align: center;
      padding: 48px 20px;
      color: #aaa;
      font-size: 0.95rem;
    }
    .library-item {
      position: relative;
      background: #fafbfc;
      border: 2px solid #eee;
      border-radius: 12px;
      padding: 14px 10px 10px;
      text-align: center;
      cursor: pointer;
      transition: all 0.2s;
      user-select: none;
    }
    .library-item:hover { border-color: #c4c9d4; }
    .library-item.selected {
      border-color: #667eea;
      background: #f0f1ff;
      box-shadow: 0 0 0 3px rgba(102,126,234,0.15);
    }
    .library-item .lib-check {
      position: absolute;
      top: 8px;
      right: 8px;
      width: 22px;
      height: 22px;
      border-radius: 50%;
      border: 2px solid #ccc;
      background: #fff;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 12px;
      color: transparent;
      transition: all 0.2s;
    }
    .library-item.selected .lib-check {
      border-color: #667eea;
      background: #667eea;
      color: #fff;
    }
    .library-item img {
      width: 60px;
      height: 60px;
      object-fit: contain;
      border-radius: 12px;
      margin-bottom: 8px;
      background: #fff;
      box-shadow: 0 1px 4px rgba(0,0,0,0.08);
    }
    .library-item .lib-name {
      font-size: 0.85rem;
      font-weight: 500;
      color: #333;
      max-width: 140px;
      margin: 0 auto;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }
    .library-item .lib-cat {
      font-size: 0.75rem;
      color: #667eea;
      margin-top: 2px;
      max-width: 140px;
      margin-left: auto;
      margin-right: auto;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }
  </style>
</head>
<body>

<div class="header">
  <h1>Logo å¢™ç”Ÿæˆå™¨</h1>
  <p>ä»æˆªå›¾ä¸­è£å‰ª Logoï¼Œæˆ–ç›´æ¥ä¸Šä¼  Logo å›¾ç‰‡ï¼Œä¸€é”®ç”Ÿæˆç²¾ç¾ Logo å¢™</p>
</div>

<div class="container">
  <!-- æ‰¹é‡è®¾ç½®ï¼šäº§å“ + åŒºåŸŸ -->
  <div class="batch-settings" id="batchSettings">
    <div class="batch-settings-title">é‡‡é›†å‰è®¾ç½®ï¼ˆå°†åº”ç”¨åˆ°åç»­æ‰€æœ‰é‡‡é›†çš„ Logoï¼‰</div>
    <div class="batch-settings-row">
      <label>é€‰æ‹©äº§å“ï¼š</label>
      <div class="product-options" id="productOptions">
        <button class="product-btn active" data-product="IM">IM</button>
        <button class="product-btn" data-product="RTC">RTC</button>
        <button class="product-btn" data-product="ç¾é¢œ">ç¾é¢œ</button>
      </div>
    </div>
    <div class="batch-settings-row">
      <label>é€‰æ‹©åŒºåŸŸï¼š</label>
      <div class="region-options" id="regionOptions">
        <button class="region-btn active" data-region="ä¸­å›½å¤§é™†">ä¸­å›½å¤§é™†</button>
        <button class="region-btn" data-region="ä¸­å›½æ¸¯æ¾³å°">ä¸­å›½æ¸¯æ¾³å°</button>
        <button class="region-btn" data-region="æ—¥æœ¬">æ—¥æœ¬</button>
        <button class="region-btn" data-region="éŸ©å›½">éŸ©å›½</button>
        <button class="region-btn" data-region="ä¸œå—äºš">ä¸œå—äºš</button>
        <button class="region-btn" data-region="å—äºš">å—äºš</button>
        <button class="region-btn" data-region="ä¸­ä¸œ">ä¸­ä¸œ</button>
        <button class="region-btn" data-region="æ¬§æ´²">æ¬§æ´²</button>
        <button class="region-btn" data-region="åŒ—ç¾">åŒ—ç¾</button>
        <button class="region-btn" data-region="æ‹‰ç¾">æ‹‰ç¾</button>
        <button class="region-btn" data-region="éæ´²">éæ´²</button>
        <button class="region-btn" data-region="å…¶ä»–">å…¶ä»–</button>
      </div>
    </div>
  </div>

  <!-- æ¨¡å¼åˆ‡æ¢ -->
  <div class="tabs">
    <button class="tab-btn active" data-tab="crop">ä»æˆªå›¾è£å‰ª Logo</button>
    <button class="tab-btn" data-tab="direct">ç›´æ¥ä¸Šä¼  Logo</button>
    <button class="tab-btn" data-tab="library">æˆ‘çš„ Logo åº“</button>
  </div>

  <!-- æ¨¡å¼ä¸€ï¼šæˆªå›¾è£å‰ª -->
  <div class="tab-content active" id="tab-crop">
    <div class="card">
      <h3>ä¸Šä¼ åŒ…å« Logo åˆ—è¡¨çš„æˆªå›¾</h3>
      <div class="upload-area" id="cropUploadArea">
        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="1.5">
          <path stroke-linecap="round" stroke-linejoin="round" d="M3 16.5v2.25A2.25 2.25 0 005.25 21h13.5A2.25 2.25 0 0021 18.75V16.5m-13.5-9L12 3m0 0l4.5 4.5M12 3v13.5"/>
        </svg>
        <h3>ç‚¹å‡»æˆ–æ‹–æ‹½ä¸Šä¼ æˆªå›¾</h3>
        <p>ä¸Šä¼ åŒ…å«å¤šä¸ª Logo çš„æˆªå›¾ï¼Œç„¶åæ¡†é€‰æ¯ä¸ª Logo</p>
        <input type="file" id="cropFileInput" accept="image/*">
      </div>

      <div class="crop-workspace" id="cropWorkspace">
        <div class="crop-instructions">
          <strong>æ“ä½œè¯´æ˜ï¼š</strong>åœ¨ä¸‹æ–¹å›¾ç‰‡ä¸ŠæŒ‰ä½é¼ æ ‡æ‹–åŠ¨ï¼Œæ¡†é€‰ä¸€ä¸ª Logo åŒºåŸŸï¼Œæ¾å¼€åè‡ªåŠ¨è¯†åˆ«åç§°ã€‚æˆ–ç‚¹å‡»ã€Œæ™ºèƒ½è¯†åˆ«ã€ä¸€é”®æ£€æµ‹æ‰€æœ‰ Logoã€‚
          <div style="margin-top:10px;">
            <button class="btn btn-primary" id="autoDetectBtn" style="padding:8px 20px;font-size:0.88rem;">æ™ºèƒ½è¯†åˆ«æ‰€æœ‰ Logo</button>
            <span id="autoDetectStatus" style="margin-left:10px;font-size:0.85rem;color:#667eea;"></span>
          </div>
        </div>
        <div class="crop-canvas-container" id="cropContainer">
          <img id="cropImage" src="" alt="æˆªå›¾">
          <div id="cropSelectionOverlay" class="crop-selection-overlay"></div>
          <div id="cropRect" class="crop-rect"></div>
        </div>

        <h3 style="margin-top:20px;">å·²è£å‰ªçš„ Logoï¼ˆ<span id="cropCount">0</span> ä¸ªï¼‰</h3>
        <div class="crop-list" id="cropList"></div>
      </div>
    </div>
  </div>

  <!-- æ¨¡å¼äºŒï¼šç›´æ¥ä¸Šä¼  -->
  <div class="tab-content" id="tab-direct">
    <div class="card">
      <h3>ç›´æ¥ä¸Šä¼  Logo å›¾ç‰‡</h3>
      <div class="upload-area" id="directUploadArea">
        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="1.5">
          <path stroke-linecap="round" stroke-linejoin="round" d="M3 16.5v2.25A2.25 2.25 0 005.25 21h13.5A2.25 2.25 0 0021 18.75V16.5m-13.5-9L12 3m0 0l4.5 4.5M12 3v13.5"/>
        </svg>
        <h3>ç‚¹å‡»æˆ–æ‹–æ‹½ä¸Šä¼  Logo å›¾ç‰‡</h3>
        <p>æ”¯æŒ JPGã€PNGã€SVGã€WebPï¼Œå¯ä¸€æ¬¡é€‰æ‹©å¤šå¼ </p>
        <input type="file" id="directFileInput" multiple accept="image/*">
      </div>

      <div class="direct-upload-grid" id="directGrid"></div>
    </div>
  </div>

  <!-- æ¨¡å¼ä¸‰ï¼šæˆ‘çš„Logoåº“ -->
  <div class="tab-content" id="tab-library">
    <div class="card">
      <div style="display:flex;align-items:center;justify-content:space-between;margin-bottom:16px;">
        <h3 style="margin-bottom:0;">æˆ‘çš„ Logo åº“ï¼ˆ<span id="libraryCount">0</span> ä¸ªï¼‰</h3>
        <div style="display:flex;gap:8px;align-items:center;">
          <button class="btn btn-primary" id="libraryGenerateBtn" style="padding:8px 18px;font-size:0.88rem;">ç”¨é€‰ä¸­é¡¹ç”Ÿæˆ Logo å¢™</button>
          <button class="btn btn-secondary" id="libraryImportJsonBtn" style="padding:8px 14px;font-size:0.85rem;margin-left:0;background:#52c41a22;color:#52c41a;border:1px solid #52c41a;">ğŸ“¥ å¯¼å…¥ JSON</button>
          <button class="btn btn-secondary" id="librarySelectAllBtn" style="padding:8px 14px;font-size:0.85rem;margin-left:0;">å…¨é€‰</button>
          <button class="btn btn-danger" id="libraryDeleteSelectedBtn" style="padding:8px 14px;font-size:0.85rem;margin-left:0;">åˆ é™¤é€‰ä¸­</button>
          <input type="file" id="jsonImportInput" accept=".json" style="display:none;">
        </div>
      </div>
      <div class="library-filter" id="libraryFilter">
        <span class="filter-tag active" data-category="all">å…¨éƒ¨</span>
      </div>
      <div class="library-grid" id="libraryGrid">
        <div class="library-empty">Logo åº“ä¸ºç©ºï¼Œå»è£å‰ªæˆ–ä¸Šä¼  Logo å§</div>
      </div>
    </div>
  </div>

  <!-- ç”ŸæˆæŒ‰é’® -->
  <div class="generate-bar" id="generateBar">
    <button class="btn btn-primary" id="generateBtn">ç”Ÿæˆ Logo å¢™</button>
    <button class="btn btn-primary" id="exportExcelBarBtn" style="background:linear-gradient(135deg,#36d1dc,#5b86e5);">å¯¼å‡º Excel</button>
    <button class="btn btn-primary" id="exportPptBarBtn" style="background:linear-gradient(135deg,#f5af19,#f12711);">å¯¼å‡º PPT</button>
    <button class="btn btn-secondary" id="saveToLibBtn" style="background:#667eea22;color:#667eea;border:1px solid #667eea;">å­˜å…¥ Logo åº“</button>
    <button class="btn btn-danger" id="clearAllBtn">æ¸…ç©ºå…¨éƒ¨</button>
  </div>

  <!-- Logo å¢™å±•ç¤º -->
  <div class="wall-section" id="wallSection">
    <div class="wall-toolbar">
      <label>
        å¸ƒå±€
        <select id="wallLayout">
          <option value="grid">ç½‘æ ¼</option>
          <option value="flex">å¼¹æ€§</option>
        </select>
      </label>
      <label>
        Logo å¤§å°
        <input type="range" id="wallSize" min="40" max="120" value="64">
      </label>
      <label>
        é—´è·
        <input type="range" id="wallGap" min="12" max="60" value="28">
      </label>
      <label>
        èƒŒæ™¯è‰²
        <input type="color" id="wallBg" value="#ffffff">
      </label>
      <label>
        <input type="checkbox" id="wallGrayscale"> ç°åº¦
      </label>
      <label>
        <input type="checkbox" id="wallHideNames"> éšè—åç§°
      </label>
      <div class="wall-toolbar-actions">
        <button class="btn btn-primary" id="exportBtn">å¯¼å‡ºå›¾ç‰‡</button>
        <button class="btn btn-primary" id="exportExcelBtn" style="background:linear-gradient(135deg,#36d1dc,#5b86e5);">å¯¼å‡º Excel</button>
        <button class="btn btn-primary" id="exportPptBtn" style="background:linear-gradient(135deg,#f5af19,#f12711);">å¯¼å‡º PPT</button>
        <button class="btn btn-secondary" id="backEditBtn">è¿”å›ç¼–è¾‘</button>
      </div>
    </div>

    <div class="logo-wall-wrapper" id="wallWrapper">
      <div class="logo-wall" id="logoWall"></div>
    </div>
  </div>
</div>

<script>
  // ============ OCR.spaceé…ç½®ï¼ˆå‰ç«¯å¯ç›´æ¥è°ƒç”¨ï¼‰ ============
  const OCR_SPACE_API_KEY = 'K89602487588957';

  // OCR.spaceè°ƒç”¨ï¼ˆå‘é€åŸå§‹å½©è‰²å›¾ç‰‡ï¼Œä¸åšäºŒå€¼åŒ–ï¼‰
  async function ocrSpaceOCR(base64Image) {
    try {
      const form = new FormData();
      form.append('apikey', OCR_SPACE_API_KEY);
      form.append('base64Image', base64Image); // ç›´æ¥å‘é€å®Œæ•´base64ï¼ˆå«å‰ç¼€ï¼‰
      form.append('language', 'chs'); // ç®€ä½“ä¸­æ–‡
      form.append('OCREngine', '2');  // Engine 2 æ›´é€‚åˆä¸­æ–‡
      form.append('scale', 'true');   // è‡ªåŠ¨æ”¾å¤§
      form.append('isOverlayRequired', 'false');

      const res = await fetch('https://api.ocr.space/parse/image', {
        method: 'POST',
        body: form
      });

      const data = await res.json();
      console.log('[OCR.spaceåŸå§‹å“åº”]', JSON.stringify(data).substring(0, 500));
      
      if (data && data.ParsedResults && data.ParsedResults.length > 0) {
        const parsed = data.ParsedResults[0];
        if (parsed.ErrorMessage) {
          console.warn('[OCR.spaceé”™è¯¯]', parsed.ErrorMessage);
          return null;
        }
        const text = (parsed.ParsedText || '').trim();
        if (text) {
          console.log('[OCR.spaceè¯†åˆ«æˆåŠŸ]', text);
          return text;
        }
      }
      return null;
    } catch (err) {
      console.warn('[OCR.spaceå¤±è´¥]', err);
      return null;
    }
  }

  // Tesseracté™çº§OCRï¼ˆä»…åœ¨OCR.spaceå¤±è´¥æ—¶ä½¿ç”¨ï¼‰
  async function tesseractOCR(base64Image, mode) {
    try {
      const { data: { text } } = await Tesseract.recognize(
        base64Image,
        'chi_sim+eng',
        { logger: () => {} }
      );
      return (text || '').trim();
    } catch (err) {
      console.warn('[Tesseractå¤±è´¥]', err);
      return '';
    }
  }

  // ç»Ÿä¸€OCRå…¥å£ï¼šOCR.spaceä¼˜å…ˆ â†’ Tesseracté™çº§
  async function doOCR(base64ImageOriginal, base64ImageProcessed) {
    // 1. å…ˆç”¨OCR.spaceè¯†åˆ«åŸå§‹å½©è‰²å›¾ç‰‡ï¼ˆäº‘ç«¯å¼•æ“è‡ªå·±å¤„ç†æ•ˆæœæœ€å¥½ï¼‰
    const cloudResult = await ocrSpaceOCR(base64ImageOriginal);
    if (cloudResult) {
      return cloudResult;
    }
    
    // 2. OCR.spaceå¤±è´¥ï¼Œç”¨Tesseractè¯†åˆ«é¢„å¤„ç†åçš„å›¾ç‰‡
    console.log('[OCRé™çº§] ä½¿ç”¨Tesseract');
    const localResult = await tesseractOCR(base64ImageProcessed, '7');
    return localResult || '';
  }

  // æ¸…ç†OCRæ–‡æœ¬ï¼šå»é™¤åƒåœ¾å­—ç¬¦ï¼Œä¿ç•™æœ‰æ„ä¹‰çš„ä¸­è‹±æ–‡
  function postProcessOcrText(raw) {
    if (!raw) return '';
    // åˆå¹¶ä¸­æ–‡å­—ç¬¦é—´çš„ç©ºæ ¼
    let text = raw.replace(/([\u4e00-\u9fa5])\s+([\u4e00-\u9fa5])/g, '$1$2');
    text = text.replace(/([\u4e00-\u9fa5])\s+([\u4e00-\u9fa5])/g, '$1$2');
    // å»é™¤ç‰¹æ®Šç¬¦å·ï¼ˆä¿ç•™ä¸­æ–‡ã€è‹±æ–‡ã€ç©ºæ ¼ï¼‰
    text = text.replace(/[^a-zA-Z\u4e00-\u9fa5\s]/g, '');
    text = text.trim();
    return text;
  }

  // ============ æ•°æ® ============
  let logoEntries = [];

  // äº§å“åˆ—è¡¨
  const PRODUCTS = ['IM', 'RTC', 'ç¾é¢œ'];
  let currentProduct = 'IM'; // å…¨å±€å½“å‰é€‰ä¸­çš„äº§å“

  // åœ°åŒºåˆ—è¡¨
  const REGIONS = ['ä¸­å›½å¤§é™†', 'ä¸­å›½æ¸¯æ¾³å°', 'æ—¥æœ¬', 'éŸ©å›½', 'ä¸œå—äºš', 'å—äºš', 'ä¸­ä¸œ', 'æ¬§æ´²', 'åŒ—ç¾', 'æ‹‰ç¾', 'éæ´²', 'å…¶ä»–'];

  // Appåç§° â†’ åœ°åŒºæ˜ å°„ï¼ˆæ ¹æ®Appè¯­è¨€/æ¥æºè‡ªåŠ¨è¯†åˆ«ï¼‰
  const APP_REGION_MAP = {
    // æ—¥æœ¬App
    'LINE': 'æ—¥æœ¬', 'PayPay': 'æ—¥æœ¬', 'ãƒ¡ãƒ«ã‚«ãƒª': 'æ—¥æœ¬', 'Yahoo!': 'æ—¥æœ¬',
    'SmartNews': 'æ—¥æœ¬', 'AbemaTV': 'æ—¥æœ¬', 'dTV': 'æ—¥æœ¬', 'U-NEXT': 'æ—¥æœ¬',
    'Rakuten': 'æ—¥æœ¬', 'æ¥½å¤©': 'æ—¥æœ¬', 'DAZN': 'æ—¥æœ¬',
    // éŸ©å›½App
    'KakaoTalk': 'éŸ©å›½', 'Kakao': 'éŸ©å›½', 'Naver': 'éŸ©å›½', 'Coupang': 'éŸ©å›½',
    'Toss': 'éŸ©å›½', 'BAND': 'éŸ©å›½', 'Baemin': 'éŸ©å›½',
    // ä¸œå—äºšApp
    'Grab': 'ä¸œå—äºš', 'Gojek': 'ä¸œå—äºš', 'Shopee': 'ä¸œå—äºš', 'Lazada': 'ä¸œå—äºš',
    'Tokopedia': 'ä¸œå—äºš', 'Bukalapak': 'ä¸œå—äºš', 'GCash': 'ä¸œå—äºš',
    'Dana': 'ä¸œå—äºš', 'OVO': 'ä¸œå—äºš', 'Momo': 'ä¸œå—äºš',
    // å—äºšApp
    'Paytm': 'å—äºš', 'PhonePe': 'å—äºš', 'Flipkart': 'å—äºš', 'Swiggy': 'å—äºš',
    'Zomato': 'å—äºš', 'Ola': 'å—äºš', 'JioMart': 'å—äºš',
    // ä¸­ä¸œApp
    'Careem': 'ä¸­ä¸œ', 'Noon': 'ä¸­ä¸œ', 'HungerStation': 'ä¸­ä¸œ', 'Talabat': 'ä¸­ä¸œ',
    // åŒ—ç¾App
    'Uber': 'åŒ—ç¾', 'Lyft': 'åŒ—ç¾', 'DoorDash': 'åŒ—ç¾', 'Venmo': 'åŒ—ç¾',
    'Cash App': 'åŒ—ç¾', 'Hulu': 'åŒ—ç¾',
    // æ¬§æ´²App
    'Revolut': 'æ¬§æ´²', 'N26': 'æ¬§æ´²', 'Bolt': 'æ¬§æ´²', 'Deliveroo': 'æ¬§æ´²',
    'Just Eat': 'æ¬§æ´²', 'Glovo': 'æ¬§æ´²',
    // æ‹‰ç¾App
    'Mercado Libre': 'æ‹‰ç¾', 'Rappi': 'æ‹‰ç¾', 'iFood': 'æ‹‰ç¾', 'Nubank': 'æ‹‰ç¾',
    // å…¨çƒAppï¼ˆä¸åšåœ°åŒºå½’å±ï¼Œéœ€äººå·¥é€‰ï¼‰
    'WhatsApp': '', 'Instagram': '', 'Facebook': '', 'TikTok': '', 'YouTube': '',
    'Twitter': '', 'X': '', 'Telegram': '', 'Discord': '', 'Zoom': '',
    'Netflix': '', 'Spotify': '', 'Amazon': '',
  };

  // æ ¹æ®Appåç§°ä¸­çš„æ–‡å­—ç‰¹å¾çŒœæµ‹åœ°åŒº
  function guessRegionByName(name) {
    if (!name) return '';
    // 1. å…ˆæŸ¥æ˜ å°„è¡¨
    if (APP_REGION_MAP[name] !== undefined) return APP_REGION_MAP[name];
    // æ¨¡ç³ŠåŒ¹é…æ˜ å°„è¡¨
    for (const [key, region] of Object.entries(APP_REGION_MAP)) {
      if (name.includes(key) || key.includes(name)) return region;
    }
    // 2. æ ¹æ®æ–‡å­—ç‰¹å¾åˆ¤æ–­
    // æ—¥æ–‡å‡å
    if (/[\u3040-\u309F\u30A0-\u30FF]/.test(name)) return 'æ—¥æœ¬';
    // éŸ©æ–‡
    if (/[\uAC00-\uD7AF\u1100-\u11FF]/.test(name)) return 'éŸ©å›½';
    // é˜¿æ‹‰ä¼¯æ–‡
    if (/[\u0600-\u06FF]/.test(name)) return 'ä¸­ä¸œ';
    // æ³°æ–‡
    if (/[\u0E00-\u0E7F]/.test(name)) return 'ä¸œå—äºš';
    // å°åœ°æ–‡/å¤©åŸæ–‡
    if (/[\u0900-\u097F]/.test(name)) return 'å—äºš';
    // çº¯ä¸­æ–‡ï¼ˆå¤§æ¦‚ç‡ä¸­å›½å¤§é™†ï¼‰
    if (/^[\u4e00-\u9fa5]+$/.test(name)) return 'ä¸­å›½å¤§é™†';
    // ä¸­è‹±æ··åˆï¼ˆå¤§æ¦‚ç‡ä¸­å›½å¤§é™†ï¼‰
    if (/[\u4e00-\u9fa5]/.test(name)) return 'ä¸­å›½å¤§é™†';
    return '';
  }
  // ============ Logo åº“ (localStorage æŒä¹…åŒ–) ============
  const LIBRARY_KEY = 'logo_wall_library';

  function loadLibrary() {
    try {
      const data = localStorage.getItem(LIBRARY_KEY);
      return data ? JSON.parse(data) : [];
    } catch(e) { return []; }
  }

  function saveLibrary(lib) {
    try {
      localStorage.setItem(LIBRARY_KEY, JSON.stringify(lib));
    } catch(e) {
      alert('å­˜å‚¨ç©ºé—´ä¸è¶³ï¼Œè¯·åˆ é™¤éƒ¨åˆ†Logoåé‡è¯•');
    }
  }

  function addToLibrary(items) {
    const lib = loadLibrary();
    items.forEach(item => {
      // æŒ‰åç§°+å›¾ç‰‡å»é‡
      const exists = lib.some(l => l.name === item.name && l.src === item.src);
      if (!exists) {
        lib.push({
          id: Date.now() + '_' + Math.random().toString(36).slice(2, 8),
          src: item.src,
          name: item.name || 'æœªå‘½å',
          category: item.category || '',
          subcategory: item.subcategory || '',
          product: item.product || '',
          region: item.region || '',
          addedAt: Date.now()
        });
      }
    });
    saveLibrary(lib);
    renderLibrary();
  }

  function removeFromLibrary(ids) {
    let lib = loadLibrary();
    lib = lib.filter(item => !ids.includes(item.id));
    saveLibrary(lib);
    renderLibrary();
  }

  // ============ App ç±»åˆ«ç³»ç»Ÿï¼ˆå¤§åˆ†ç±» + å°åˆ†ç±»ï¼‰ ============
  const CATEGORY_TREE = {
    'å•†åŠ¡åŠå…¬': ['åœ¨çº¿ä¼šè®®', 'å•†åŠ¡æ²Ÿé€š', 'é¡¹ç›®ç®¡ç†', 'æ–‡æ¡£åä½œ', 'ä¼ä¸šç®¡ç†', 'åŠå…¬å·¥å…·', 'æ±‚èŒæ‹›è˜', 'å…¶ä»–'],
    'ç¤¾äº¤èŠå¤©': ['å³æ—¶é€šè®¯', 'ç¤¾åŒºè®ºå›', 'å©šæ‹äº¤å‹', 'å…´è¶£ç¤¾äº¤', 'å…¶ä»–'],
    'å¨±ä¹': ['OTT', 'çŸ­è§†é¢‘', 'ç›´æ’­', 'éŸ³ä¹ä¸éŸ³é¢‘', 'æ’­å®¢', 'å…¶ä»–'],
    'è´­ç‰©': ['ç»¼åˆç”µå•†', 'äºŒæ‰‹äº¤æ˜“', 'ç‰¹å–æŠ˜æ‰£', 'è·¨å¢ƒç”µå•†', 'å…¶ä»–'],
    'ç”Ÿæ´»æœåŠ¡': ['å¤–å–é…é€', 'æœ¬åœ°ç”Ÿæ´»', 'å¿«é€’ç‰©æµ', 'å¥³æ€§å¥åº·', 'æ‹ç…§å·¥å…·', 'äºŒæ‰‹äº¤æ˜“', 'å®¶ç”¨ç”µå™¨', 'é€šä¿¡è¿è¥', 'ä¾¿åˆ©åº—', 'å©šåº†æœåŠ¡', 'å…¶ä»–'],
    'é‡‘èç†è´¢': ['é“¶è¡Œ', 'æ”¯ä»˜', 'æŠ•èµ„ç†è´¢', 'ä¿é™©', 'å€Ÿè´·', 'å…¶ä»–'],
    'å‡ºè¡Œå¯¼èˆª': ['åœ°å›¾å¯¼èˆª', 'æ‰“è½¦å‡ºè¡Œ', 'å…±äº«å•è½¦', 'è´§è¿', 'å…¶ä»–'],
    'æ—…æ¸¸å‡ºè¡Œ': ['ç»¼åˆæ—…æ¸¸æœåŠ¡', 'é…’åº—ä½å®¿', 'æœºç¥¨ç«è½¦', 'æ—…è¡Œæ”»ç•¥', 'å…¶ä»–'],
    'æ•™è‚²å­¦ä¹ ': ['K12æ•™è‚²', 'èŒä¸šåŸ¹è®­', 'è¯­è¨€å­¦ä¹ ', 'åœ¨çº¿è¯¾ç¨‹', 'å…¶ä»–'],
    'æ¸¸æˆ': ['å°„å‡»', 'å›¢é˜Ÿç«æŠ€', 'MOBA', 'RPG', 'ä¼‘é—²ç›Šæ™º', 'æ£‹ç‰Œ', 'å…¶ä»–'],
    'æ–°é—»èµ„è®¯': ['ç»¼åˆæ–°é—»', 'è´¢ç»èµ„è®¯', 'ç§‘æŠ€èµ„è®¯', 'ä½“è‚²èµ„è®¯', 'å…¶ä»–'],
    'ç…§ç‰‡è§†é¢‘': ['ç…§ç‰‡ç¼–è¾‘', 'è§†é¢‘ç¼–è¾‘', 'ç›¸æœºå·¥å…·', 'ç¾é¢œæ»¤é•œ', 'å…¶ä»–'],
    'å¥èº«å¥åº·': ['è¿åŠ¨å¥èº«', 'åŒ»ç–—å¥åº·', 'å¥³æ€§å¥åº·', 'å¿ƒç†å¥åº·', 'åœ¨çº¿åŒ»ç–—', 'å…¶ä»–'],
    'é˜…è¯»æ–‡å­¦': ['å°è¯´é˜…è¯»', 'ç”µå­ä¹¦', 'æœ‰å£°ä¹¦', 'æ¼«ç”»', 'å…¶ä»–'],
    'æˆ¿äº§å®¶å±…': ['ç§Ÿæˆ¿ä¹°æˆ¿', 'å®¶è£…è®¾è®¡', 'æ™ºèƒ½å®¶å±…', 'å…¶ä»–'],
    'AI äººå·¥æ™ºèƒ½': ['AIåŠ©æ‰‹', 'AIåˆ›ä½œ', 'AIå·¥å…·', 'å…¶ä»–'],
    'ç¾é£Ÿé¤é¥®': ['é¤å…æ¨è', 'ç¾é£Ÿèœè°±', 'é£Ÿå“ç”Ÿé²œ', 'å…¶ä»–'],
    'æ±½è½¦æœåŠ¡': ['ä¹°è½¦å–è½¦', 'è½¦ä¸»æœåŠ¡', 'å……ç”µåŠ æ²¹', 'å…¶ä»–'],
    'å·¥å…·æ•ˆç‡': ['æµè§ˆå™¨', 'ç³»ç»Ÿå·¥å…·', 'æ–‡ä»¶ç®¡ç†', 'æ•ˆç‡å·¥å…·', 'å…¶ä»–'],
    'å…¶ä»–': ['å…¶ä»–']
  };

  const MAJOR_CATEGORIES = Object.keys(CATEGORY_TREE);

  // å¸¸è§ App åç§° â†’ { major, minor } æ˜ å°„
  const APP_NAME_CATEGORY_MAP = {
    'å¾®ä¿¡': { major: 'ç¤¾äº¤èŠå¤©', minor: 'å³æ—¶é€šè®¯' },
    'QQ': { major: 'ç¤¾äº¤èŠå¤©', minor: 'å³æ—¶é€šè®¯' },
    'é’‰é’‰': { major: 'å•†åŠ¡åŠå…¬', minor: 'ä¼ä¸šç®¡ç†' },
    'é£ä¹¦': { major: 'å•†åŠ¡åŠå…¬', minor: 'ä¼ä¸šç®¡ç†' },
    'ä¼ä¸šå¾®ä¿¡': { major: 'å•†åŠ¡åŠå…¬', minor: 'å•†åŠ¡æ²Ÿé€š' },
    'å¾®åš': { major: 'ç¤¾äº¤èŠå¤©', minor: 'ç¤¾åŒºè®ºå›' },
    'å°çº¢ä¹¦': { major: 'ç¤¾äº¤èŠå¤©', minor: 'å…´è¶£ç¤¾äº¤' },
    'æŠ–éŸ³': { major: 'å¨±ä¹', minor: 'çŸ­è§†é¢‘' },
    'å¿«æ‰‹': { major: 'å¨±ä¹', minor: 'çŸ­è§†é¢‘' },
    'è¥¿ç“œè§†é¢‘': { major: 'å¨±ä¹', minor: 'OTT' },
    'Bç«™': { major: 'å¨±ä¹', minor: 'OTT' },
    'å“”å“©å“”å“©': { major: 'å¨±ä¹', minor: 'OTT' },
    'ä¼˜é…·': { major: 'å¨±ä¹', minor: 'OTT' },
    'çˆ±å¥‡è‰º': { major: 'å¨±ä¹', minor: 'OTT' },
    'è…¾è®¯è§†é¢‘': { major: 'å¨±ä¹', minor: 'OTT' },
    'èŠ’æœTV': { major: 'å¨±ä¹', minor: 'OTT' },
    'æ·˜å®': { major: 'è´­ç‰©', minor: 'ç»¼åˆç”µå•†' },
    'å¤©çŒ«': { major: 'è´­ç‰©', minor: 'ç»¼åˆç”µå•†' },
    'äº¬ä¸œ': { major: 'è´­ç‰©', minor: 'ç»¼åˆç”µå•†' },
    'æ‹¼å¤šå¤š': { major: 'è´­ç‰©', minor: 'ç»¼åˆç”µå•†' },
    'å”¯å“ä¼š': { major: 'è´­ç‰©', minor: 'ç‰¹å–æŠ˜æ‰£' },
    'é—²é±¼': { major: 'è´­ç‰©', minor: 'äºŒæ‰‹äº¤æ˜“' },
    'å¾—ç‰©': { major: 'è´­ç‰©', minor: 'ç»¼åˆç”µå•†' },
    '1688': { major: 'è´­ç‰©', minor: 'ç»¼åˆç”µå•†' },
    'ä¸€æ‰‹æœè£…': { major: 'è´­ç‰©', minor: 'ç»¼åˆç”µå•†' },
    'æœ´æœ´è¶…å¸‚': { major: 'ç”Ÿæ´»æœåŠ¡', minor: 'å¤–å–é…é€' },
    'æœ´æœ´': { major: 'ç”Ÿæ´»æœåŠ¡', minor: 'å¤–å–é…é€' },
    'ç¾å›¢': { major: 'ç”Ÿæ´»æœåŠ¡', minor: 'å¤–å–é…é€' },
    'é¥¿äº†ä¹ˆ': { major: 'ç”Ÿæ´»æœåŠ¡', minor: 'å¤–å–é…é€' },
    'ç›’é©¬': { major: 'ç”Ÿæ´»æœåŠ¡', minor: 'å¤–å–é…é€' },
    'å®å’šä¹°èœ': { major: 'ç”Ÿæ´»æœåŠ¡', minor: 'å¤–å–é…é€' },
    'è´§æ‹‰æ‹‰': { major: 'å‡ºè¡Œå¯¼èˆª', minor: 'è´§è¿' },
    'è´§æ‹‰æ‹‰å¸æœºç‰ˆ': { major: 'å‡ºè¡Œå¯¼èˆª', minor: 'è´§è¿' },
    'æ”¯ä»˜å®': { major: 'é‡‘èç†è´¢', minor: 'æ”¯ä»˜' },
    'äº‘é—ªä»˜': { major: 'é‡‘èç†è´¢', minor: 'æ”¯ä»˜' },
    'æ‹›å•†é“¶è¡Œ': { major: 'é‡‘èç†è´¢', minor: 'é“¶è¡Œ' },
    'å·¥å•†é“¶è¡Œ': { major: 'é‡‘èç†è´¢', minor: 'é“¶è¡Œ' },
    'å»ºè®¾é“¶è¡Œ': { major: 'é‡‘èç†è´¢', minor: 'é“¶è¡Œ' },
    'å†œä¸šé“¶è¡Œ': { major: 'é‡‘èç†è´¢', minor: 'é“¶è¡Œ' },
    'ä¸­å›½é“¶è¡Œ': { major: 'é‡‘èç†è´¢', minor: 'é“¶è¡Œ' },
    'äº¤é€šé“¶è¡Œ': { major: 'é‡‘èç†è´¢', minor: 'é“¶è¡Œ' },
    'æ°‘ç”Ÿé“¶è¡Œ': { major: 'é‡‘èç†è´¢', minor: 'é“¶è¡Œ' },
    'æµ¦å‘é“¶è¡Œ': { major: 'é‡‘èç†è´¢', minor: 'é“¶è¡Œ' },
    'å…´ä¸šé“¶è¡Œ': { major: 'é‡‘èç†è´¢', minor: 'é“¶è¡Œ' },
    'å…‰å¤§é“¶è¡Œ': { major: 'é‡‘èç†è´¢', minor: 'é“¶è¡Œ' },
    'ä¸­ä¿¡é“¶è¡Œ': { major: 'é‡‘èç†è´¢', minor: 'é“¶è¡Œ' },
    'åå¤é“¶è¡Œ': { major: 'é‡‘èç†è´¢', minor: 'é“¶è¡Œ' },
    'å¹³å®‰é“¶è¡Œ': { major: 'é‡‘èç†è´¢', minor: 'é“¶è¡Œ' },
    'ä¹°å•å§': { major: 'é‡‘èç†è´¢', minor: 'æ”¯ä»˜' },
    'æ–°æµªè´¢ç»': { major: 'æ–°é—»èµ„è®¯', minor: 'è´¢ç»èµ„è®¯' },
    'ç™¾åº¦åœ°å›¾': { major: 'å‡ºè¡Œå¯¼èˆª', minor: 'åœ°å›¾å¯¼èˆª' },
    'é«˜å¾·åœ°å›¾': { major: 'å‡ºè¡Œå¯¼èˆª', minor: 'åœ°å›¾å¯¼èˆª' },
    'è…¾è®¯åœ°å›¾': { major: 'å‡ºè¡Œå¯¼èˆª', minor: 'åœ°å›¾å¯¼èˆª' },
    'æ»´æ»´å‡ºè¡Œ': { major: 'å‡ºè¡Œå¯¼èˆª', minor: 'æ‰“è½¦å‡ºè¡Œ' },
    'å°æ‹‰å‡ºè¡Œ': { major: 'å‡ºè¡Œå¯¼èˆª', minor: 'æ‰“è½¦å‡ºè¡Œ' },
    'å“ˆå•°': { major: 'å‡ºè¡Œå¯¼èˆª', minor: 'å…±äº«å•è½¦' },
    'T3å‡ºè¡Œ': { major: 'å‡ºè¡Œå¯¼èˆª', minor: 'æ‰“è½¦å‡ºè¡Œ' },
    'è‡ªå¦‚': { major: 'æˆ¿äº§å®¶å±…', minor: 'ç§Ÿæˆ¿ä¹°æˆ¿' },
    'è´å£³æ‰¾æˆ¿': { major: 'æˆ¿äº§å®¶å±…', minor: 'ç§Ÿæˆ¿ä¹°æˆ¿' },
    'è´å£³': { major: 'æˆ¿äº§å®¶å±…', minor: 'ç§Ÿæˆ¿ä¹°æˆ¿' },
    'é“¾å®¶': { major: 'æˆ¿äº§å®¶å±…', minor: 'ç§Ÿæˆ¿ä¹°æˆ¿' },
    'å®‰å±…å®¢': { major: 'æˆ¿äº§å®¶å±…', minor: 'ç§Ÿæˆ¿ä¹°æˆ¿' },
    'çŸ¥ä¹': { major: 'æ–°é—»èµ„è®¯', minor: 'ç»¼åˆæ–°é—»' },
    'ä»Šæ—¥å¤´æ¡': { major: 'æ–°é—»èµ„è®¯', minor: 'ç»¼åˆæ–°é—»' },
    'ç½‘æ˜“æ–°é—»': { major: 'æ–°é—»èµ„è®¯', minor: 'ç»¼åˆæ–°é—»' },
    'è…¾è®¯æ–°é—»': { major: 'æ–°é—»èµ„è®¯', minor: 'ç»¼åˆæ–°é—»' },
    'æ¾æ¹ƒæ–°é—»': { major: 'æ–°é—»èµ„è®¯', minor: 'ç»¼åˆæ–°é—»' },
    'ç½‘æ˜“äº‘éŸ³ä¹': { major: 'å¨±ä¹', minor: 'éŸ³ä¹ä¸éŸ³é¢‘' },
    'QQéŸ³ä¹': { major: 'å¨±ä¹', minor: 'éŸ³ä¹ä¸éŸ³é¢‘' },
    'é…·ç‹—éŸ³ä¹': { major: 'å¨±ä¹', minor: 'éŸ³ä¹ä¸éŸ³é¢‘' },
    'æ±½æ°´éŸ³ä¹': { major: 'å¨±ä¹', minor: 'éŸ³ä¹ä¸éŸ³é¢‘' },
    'å–œé©¬æ‹‰é›…': { major: 'å¨±ä¹', minor: 'æ’­å®¢' },
    'ç™¾åº¦': { major: 'å·¥å…·æ•ˆç‡', minor: 'æµè§ˆå™¨' },
    'å¤¸å…‹': { major: 'å·¥å…·æ•ˆç‡', minor: 'æµè§ˆå™¨' },
    'UCæµè§ˆå™¨': { major: 'å·¥å…·æ•ˆç‡', minor: 'æµè§ˆå™¨' },
    'è±†åŒ…': { major: 'AI äººå·¥æ™ºèƒ½', minor: 'AIåŠ©æ‰‹' },
    'åƒé—®': { major: 'AI äººå·¥æ™ºèƒ½', minor: 'AIåŠ©æ‰‹' },
    'æ–‡å¿ƒä¸€è¨€': { major: 'AI äººå·¥æ™ºèƒ½', minor: 'AIåŠ©æ‰‹' },
    'ChatGPT': { major: 'AI äººå·¥æ™ºèƒ½', minor: 'AIåŠ©æ‰‹' },
    'Kimi': { major: 'AI äººå·¥æ™ºèƒ½', minor: 'AIåŠ©æ‰‹' },
    'DeepSeek': { major: 'AI äººå·¥æ™ºèƒ½', minor: 'AIåŠ©æ‰‹' },
    'é€šä¹‰åƒé—®': { major: 'AI äººå·¥æ™ºèƒ½', minor: 'AIåŠ©æ‰‹' },
    'ä¹‹äº†è¯¾å ‚': { major: 'æ•™è‚²å­¦ä¹ ', minor: 'èŒä¸šåŸ¹è®­' },
    'å­¦è€Œæ€': { major: 'æ•™è‚²å­¦ä¹ ', minor: 'K12æ•™è‚²' },
    'ä½œä¸šå¸®': { major: 'æ•™è‚²å­¦ä¹ ', minor: 'K12æ•™è‚²' },
    'çŒ¿è¾…å¯¼': { major: 'æ•™è‚²å­¦ä¹ ', minor: 'K12æ•™è‚²' },
    'ç½‘æ˜“å…¬å¼€è¯¾': { major: 'æ•™è‚²å­¦ä¹ ', minor: 'åœ¨çº¿è¯¾ç¨‹' },
    'MOOC': { major: 'æ•™è‚²å­¦ä¹ ', minor: 'åœ¨çº¿è¯¾ç¨‹' },
    'ç”»ä¸–ç•Œ': { major: 'ç…§ç‰‡è§†é¢‘', minor: 'ç…§ç‰‡ç¼–è¾‘' },
    'ç¾å›¾ç§€ç§€': { major: 'ç…§ç‰‡è§†é¢‘', minor: 'ç¾é¢œæ»¤é•œ' },
    'é†’å›¾': { major: 'ç…§ç‰‡è§†é¢‘', minor: 'ç…§ç‰‡ç¼–è¾‘' },
    'æºç¨‹': { major: 'æ—…æ¸¸å‡ºè¡Œ', minor: 'ç»¼åˆæ—…æ¸¸æœåŠ¡' },
    'æºç¨‹æ—…è¡Œ': { major: 'æ—…æ¸¸å‡ºè¡Œ', minor: 'ç»¼åˆæ—…æ¸¸æœåŠ¡' },
    'é£çŒª': { major: 'æ—…æ¸¸å‡ºè¡Œ', minor: 'ç»¼åˆæ—…æ¸¸æœåŠ¡' },
    'å»å“ªå„¿': { major: 'æ—…æ¸¸å‡ºè¡Œ', minor: 'ç»¼åˆæ—…æ¸¸æœåŠ¡' },
    'åŒç¨‹æ—…è¡Œ': { major: 'æ—…æ¸¸å‡ºè¡Œ', minor: 'ç»¼åˆæ—…æ¸¸æœåŠ¡' },
    'é©¬èœ‚çª': { major: 'æ—…æ¸¸å‡ºè¡Œ', minor: 'æ—…è¡Œæ”»ç•¥' },
    'ç‹è€…è£è€€': { major: 'æ¸¸æˆ', minor: 'MOBA' },
    'å’Œå¹³ç²¾è‹±': { major: 'æ¸¸æˆ', minor: 'å°„å‡»' },
    'åŸç¥': { major: 'æ¸¸æˆ', minor: 'RPG' },
    'ç©ºçµè¯—ç¯‡': { major: 'æ¸¸æˆ', minor: 'RPG' },
    'å´©å': { major: 'æ¸¸æˆ', minor: 'RPG' },
    'æ— ç•å¥‘çº¦': { major: 'æ¸¸æˆ', minor: 'å°„å‡»' },
    'çº¢æœçŸ­å‰§': { major: 'å¨±ä¹', minor: 'çŸ­è§†é¢‘' },
    'Keep': { major: 'å¥èº«å¥åº·', minor: 'è¿åŠ¨å¥èº«' },
    'ç•ªèŒ„å°è¯´': { major: 'é˜…è¯»æ–‡å­¦', minor: 'å°è¯´é˜…è¯»' },
    'å¾®ä¿¡è¯»ä¹¦': { major: 'é˜…è¯»æ–‡å­¦', minor: 'ç”µå­ä¹¦' },
    'ä¸é¦™åŒ»ç”Ÿ': { major: 'å¥èº«å¥åº·', minor: 'åŒ»ç–—å¥åº·' },
    'å¹³å®‰å¥½åŒ»ç”Ÿ': { major: 'å¥èº«å¥åº·', minor: 'åŒ»ç–—å¥åº·' },
    'å¤§ä¼—ç‚¹è¯„': { major: 'ç¾é£Ÿé¤é¥®', minor: 'é¤å…æ¨è' },
    'ä¸‹å¨æˆ¿': { major: 'ç¾é£Ÿé¤é¥®', minor: 'ç¾é£Ÿèœè°±' },
    'è…¾è®¯ä¼šè®®': { major: 'å•†åŠ¡åŠå…¬', minor: 'åœ¨çº¿ä¼šè®®' },
    'ç¾æŸš': { major: 'å¥èº«å¥åº·', minor: 'å¥³æ€§å¥åº·' },
    'è½¬è½¬': { major: 'è´­ç‰©', minor: 'äºŒæ‰‹äº¤æ˜“' },
    'ä»Šæ—¥æ°´å°': { major: 'ç…§ç‰‡è§†é¢‘', minor: 'ç…§ç‰‡ç¼–è¾‘' },
    'ä»Šæ—¥æ°´å°ç›¸æœº': { major: 'ç…§ç‰‡è§†é¢‘', minor: 'ç…§ç‰‡ç¼–è¾‘' },
    'çŒè˜': { major: 'å•†åŠ¡åŠå…¬', minor: 'æ±‚èŒæ‹›è˜' },
    'éº¦å¾·é¾™': { major: 'è´­ç‰©', minor: 'ç»¼åˆç”µå•†' },
    'æµ·ä¿¡çˆ±å®¶': { major: 'ç”Ÿæ´»æœåŠ¡', minor: 'å®¶ç”¨ç”µå™¨' },
    'å¥½å¤§å¤«åœ¨çº¿': { major: 'å¥èº«å¥åº·', minor: 'åœ¨çº¿åŒ»ç–—' },
    'å¥½å¤§å¤«': { major: 'å¥èº«å¥åº·', minor: 'åœ¨çº¿åŒ»ç–—' },
    'å©šç¤¼çºª': { major: 'ç”Ÿæ´»æœåŠ¡', minor: 'å©šåº†æœåŠ¡' },
    'å…¨å®¶': { major: 'ç”Ÿæ´»æœåŠ¡', minor: 'ä¾¿åˆ©åº—' },
    'å…¨å®¶ä¾¿åˆ©åº—': { major: 'ç”Ÿæ´»æœåŠ¡', minor: 'ä¾¿åˆ©åº—' },
    'FamilyMart': { major: 'ç”Ÿæ´»æœåŠ¡', minor: 'ä¾¿åˆ©åº—' },
    'T-FAMI': { major: 'ç”Ÿæ´»æœåŠ¡', minor: 'ä¾¿åˆ©åº—' },
    'TFAMI': { major: 'ç”Ÿæ´»æœåŠ¡', minor: 'ä¾¿åˆ©åº—' },
    'ç½—æ£®': { major: 'ç”Ÿæ´»æœåŠ¡', minor: 'ä¾¿åˆ©åº—' },
    '7-Eleven': { major: 'ç”Ÿæ´»æœåŠ¡', minor: 'ä¾¿åˆ©åº—' },
    '711': { major: 'ç”Ÿæ´»æœåŠ¡', minor: 'ä¾¿åˆ©åº—' },
    'ä¾¿åˆ©èœ‚': { major: 'ç”Ÿæ´»æœåŠ¡', minor: 'ä¾¿åˆ©åº—' },
    'BOSSç›´è˜': { major: 'å•†åŠ¡åŠå…¬', minor: 'æ±‚èŒæ‹›è˜' },
    'æ™ºè”æ‹›è˜': { major: 'å•†åŠ¡åŠå…¬', minor: 'æ±‚èŒæ‹›è˜' },
    'å‰ç¨‹æ— å¿§': { major: 'å•†åŠ¡åŠå…¬', minor: 'æ±‚èŒæ‹›è˜' },
    'æ‹‰å‹¾': { major: 'å•†åŠ¡åŠå…¬', minor: 'æ±‚èŒæ‹›è˜' },
    'è„‰è„‰': { major: 'å•†åŠ¡åŠå…¬', minor: 'å•†åŠ¡æ²Ÿé€š' },
    '58åŒåŸ': { major: 'ç”Ÿæ´»æœåŠ¡', minor: 'æœ¬åœ°ç”Ÿæ´»' },
    'èµ¶é›†ç½‘': { major: 'ç”Ÿæ´»æœåŠ¡', minor: 'æœ¬åœ°ç”Ÿæ´»' },
    'ä¸‡èƒ½é’¥åŒ™': { major: 'å·¥å…·æ•ˆç‡', minor: 'ç³»ç»Ÿå·¥å…·' },
    'å¢¨è¿¹å¤©æ°”': { major: 'å·¥å…·æ•ˆç‡', minor: 'ç³»ç»Ÿå·¥å…·' },
    'ä¸­å›½ç§»åŠ¨': { major: 'ç”Ÿæ´»æœåŠ¡', minor: 'é€šä¿¡è¿è¥' },
    'ä¸­å›½è”é€š': { major: 'ç”Ÿæ´»æœåŠ¡', minor: 'é€šä¿¡è¿è¥' },
    'ä¸­å›½ç”µä¿¡': { major: 'ç”Ÿæ´»æœåŠ¡', minor: 'é€šä¿¡è¿è¥' },
    '12306': { major: 'æ—…æ¸¸å‡ºè¡Œ', minor: 'æœºç¥¨ç«è½¦' },
    'é“è·¯12306': { major: 'æ—…æ¸¸å‡ºè¡Œ', minor: 'æœºç¥¨ç«è½¦' },
    'æ»´æ»´': { major: 'å‡ºè¡Œå¯¼èˆª', minor: 'æ‰“è½¦å‡ºè¡Œ' },
    'æ›¹æ“å‡ºè¡Œ': { major: 'å‡ºè¡Œå¯¼èˆª', minor: 'æ‰“è½¦å‡ºè¡Œ' },
    'èŠ±å°çŒª': { major: 'å‡ºè¡Œå¯¼èˆª', minor: 'æ‰“è½¦å‡ºè¡Œ' },
    'é¡ºä¸°': { major: 'ç”Ÿæ´»æœåŠ¡', minor: 'å¿«é€’ç‰©æµ' },
    'é¡ºä¸°é€Ÿè¿': { major: 'ç”Ÿæ´»æœåŠ¡', minor: 'å¿«é€’ç‰©æµ' },
    'èœé¸Ÿ': { major: 'ç”Ÿæ´»æœåŠ¡', minor: 'å¿«é€’ç‰©æµ' },
    'èœé¸Ÿè£¹è£¹': { major: 'ç”Ÿæ´»æœåŠ¡', minor: 'å¿«é€’ç‰©æµ' },
    'æå…”': { major: 'ç”Ÿæ´»æœåŠ¡', minor: 'å¿«é€’ç‰©æµ' },
    'æå…”å¿«é€’': { major: 'ç”Ÿæ´»æœåŠ¡', minor: 'å¿«é€’ç‰©æµ' },
    'ä¸­é€š': { major: 'ç”Ÿæ´»æœåŠ¡', minor: 'å¿«é€’ç‰©æµ' },
    'ä¸­é€šå¿«é€’': { major: 'ç”Ÿæ´»æœåŠ¡', minor: 'å¿«é€’ç‰©æµ' },
    'éŸµè¾¾': { major: 'ç”Ÿæ´»æœåŠ¡', minor: 'å¿«é€’ç‰©æµ' },
    'åœ†é€š': { major: 'ç”Ÿæ´»æœåŠ¡', minor: 'å¿«é€’ç‰©æµ' },
    'ç”³é€š': { major: 'ç”Ÿæ´»æœåŠ¡', minor: 'å¿«é€’ç‰©æµ' },
    'ç‘å¹¸å’–å•¡': { major: 'ç¾é£Ÿé¤é¥®', minor: 'é¤å…æ¨è' },
    'ç‘å¹¸': { major: 'ç¾é£Ÿé¤é¥®', minor: 'é¤å…æ¨è' },
    'æ˜Ÿå·´å…‹': { major: 'ç¾é£Ÿé¤é¥®', minor: 'é¤å…æ¨è' },
    'è‚¯å¾·åŸº': { major: 'ç¾é£Ÿé¤é¥®', minor: 'é¤å…æ¨è' },
    'KFC': { major: 'ç¾é£Ÿé¤é¥®', minor: 'é¤å…æ¨è' },
    'éº¦å½“åŠ³': { major: 'ç¾é£Ÿé¤é¥®', minor: 'é¤å…æ¨è' },
    'å¿…èƒœå®¢': { major: 'ç¾é£Ÿé¤é¥®', minor: 'é¤å…æ¨è' },
    'ç›’é©¬é²œç”Ÿ': { major: 'ç”Ÿæ´»æœåŠ¡', minor: 'å¤–å–é…é€' },
    'æ¯æ—¥ä¼˜é²œ': { major: 'ç”Ÿæ´»æœåŠ¡', minor: 'å¤–å–é…é€' },
    'å±±å§†': { major: 'è´­ç‰©', minor: 'ç»¼åˆç”µå•†' },
    'å±±å§†ä¼šå‘˜åº—': { major: 'è´­ç‰©', minor: 'ç»¼åˆç”µå•†' },
    'æ°¸è¾‰': { major: 'è´­ç‰©', minor: 'ç»¼åˆç”µå•†' },
    'æ°¸è¾‰è¶…å¸‚': { major: 'è´­ç‰©', minor: 'ç»¼åˆç”µå•†' },
    'è‹å®': { major: 'è´­ç‰©', minor: 'ç»¼åˆç”µå•†' },
    'è‹å®æ˜“è´­': { major: 'è´­ç‰©', minor: 'ç»¼åˆç”µå•†' },
    'å›½ç¾': { major: 'è´­ç‰©', minor: 'ç»¼åˆç”µå•†' },
    'å½“å½“': { major: 'è´­ç‰©', minor: 'ç»¼åˆç”µå•†' },
    'ç½‘æ˜“ä¸¥é€‰': { major: 'è´­ç‰©', minor: 'ç»¼åˆç”µå•†' },
    'è€ƒæ‹‰æµ·è´­': { major: 'è´­ç‰©', minor: 'è·¨å¢ƒç”µå•†' },
    'æ´‹ç å¤´': { major: 'è´­ç‰©', minor: 'è·¨å¢ƒç”µå•†' },
    'å¤©çŒ«å›½é™…': { major: 'è´­ç‰©', minor: 'è·¨å¢ƒç”µå•†' },
    'é©¬ä¸Šåˆ°å®¶': { major: 'ç”Ÿæ´»æœåŠ¡', minor: 'å¤–å–é…é€' },
    'å¤šç‚¹': { major: 'è´­ç‰©', minor: 'ç»¼åˆç”µå•†' },
    'å¤šç‚¹è¶…å¸‚': { major: 'è´­ç‰©', minor: 'ç»¼åˆç”µå•†' },
    'ç‰©ç¾': { major: 'è´­ç‰©', minor: 'ç»¼åˆç”µå•†' },
    'å¹´è´§èŠ‚': { major: 'è´­ç‰©', minor: 'ç»¼åˆç”µå•†' },
    'ä¸‡è¾¾': { major: 'ç”Ÿæ´»æœåŠ¡', minor: 'æœ¬åœ°ç”Ÿæ´»' },
    'ä¸‡è¾¾å¹¿åœº': { major: 'ç”Ÿæ´»æœåŠ¡', minor: 'æœ¬åœ°ç”Ÿæ´»' },
    'ä¸‡è¾¾ç”µå½±': { major: 'å¨±ä¹', minor: 'å…¶ä»–' },
    'æ·˜ç¥¨ç¥¨': { major: 'å¨±ä¹', minor: 'å…¶ä»–' },
    'çŒ«çœ¼': { major: 'å¨±ä¹', minor: 'å…¶ä»–' },
    'çŒ«çœ¼ç”µå½±': { major: 'å¨±ä¹', minor: 'å…¶ä»–' },
    'å¾®åŒ»': { major: 'å¥èº«å¥åº·', minor: 'åœ¨çº¿åŒ»ç–—' },
    'æ˜¥é›¨åŒ»ç”Ÿ': { major: 'å¥èº«å¥åº·', minor: 'åœ¨çº¿åŒ»ç–—' },
    'è–„è·å¥åº·': { major: 'å¥èº«å¥åº·', minor: 'è¿åŠ¨å¥èº«' },
    'å’•å’š': { major: 'å¥èº«å¥åº·', minor: 'è¿åŠ¨å¥èº«' },
    'åä¸ºè¿åŠ¨å¥åº·': { major: 'å¥èº«å¥åº·', minor: 'è¿åŠ¨å¥èº«' },
    'å°ç±³è¿åŠ¨': { major: 'å¥èº«å¥åº·', minor: 'è¿åŠ¨å¥èº«' },
    'æ‡‚è½¦å¸': { major: 'æ±½è½¦æœåŠ¡', minor: 'ä¹°è½¦å–è½¦' },
    'æ±½è½¦ä¹‹å®¶': { major: 'æ±½è½¦æœåŠ¡', minor: 'ä¹°è½¦å–è½¦' },
    'é€”è™å…»è½¦': { major: 'æ±½è½¦æœåŠ¡', minor: 'è½¦ä¸»æœåŠ¡' },
    'ç‰¹æ¥ç”µ': { major: 'æ±½è½¦æœåŠ¡', minor: 'å……ç”µåŠ æ²¹' },
    'æ¢æ¢': { major: 'ç¤¾äº¤èŠå¤©', minor: 'å©šæ‹äº¤å‹' },
    'é™Œé™Œ': { major: 'ç¤¾äº¤èŠå¤©', minor: 'å©šæ‹äº¤å‹' },
    'ççˆ±ç½‘': { major: 'ç¤¾äº¤èŠå¤©', minor: 'å©šæ‹äº¤å‹' },
    'ä¸–çºªä½³ç¼˜': { major: 'ç¤¾äº¤èŠå¤©', minor: 'å©šæ‹äº¤å‹' },
    'Soul': { major: 'ç¤¾äº¤èŠå¤©', minor: 'å…´è¶£ç¤¾äº¤' },
    'è±†ç“£': { major: 'ç¤¾äº¤èŠå¤©', minor: 'ç¤¾åŒºè®ºå›' },
    'è™æ‰‘': { major: 'æ–°é—»èµ„è®¯', minor: 'ä½“è‚²èµ„è®¯' },
    '36æ°ª': { major: 'æ–°é—»èµ„è®¯', minor: 'ç§‘æŠ€èµ„è®¯' },
    'é›ªçƒ': { major: 'æ–°é—»èµ„è®¯', minor: 'è´¢ç»èµ„è®¯' },
    'ä¸œæ–¹è´¢å¯Œ': { major: 'é‡‘èç†è´¢', minor: 'æŠ•èµ„ç†è´¢' },
    'åŒèŠ±é¡º': { major: 'é‡‘èç†è´¢', minor: 'æŠ•èµ„ç†è´¢' },
    'èš‚èšè´¢å¯Œ': { major: 'é‡‘èç†è´¢', minor: 'æŠ•èµ„ç†è´¢' },
    'äº¬ä¸œé‡‘è': { major: 'é‡‘èç†è´¢', minor: 'æŠ•èµ„ç†è´¢' },
    'åº¦å°æ»¡': { major: 'é‡‘èç†è´¢', minor: 'å€Ÿè´·' },
    'å€Ÿå‘—': { major: 'é‡‘èç†è´¢', minor: 'å€Ÿè´·' },
    'å¾®ç²’è´·': { major: 'é‡‘èç†è´¢', minor: 'å€Ÿè´·' },
    'å®œå®¶': { major: 'æˆ¿äº§å®¶å±…', minor: 'å®¶è£…è®¾è®¡' },
    'åœŸå·´å…”': { major: 'æˆ¿äº§å®¶å±…', minor: 'å®¶è£…è®¾è®¡' },
    'é½å®¶ç½‘': { major: 'æˆ¿äº§å®¶å±…', minor: 'å®¶è£…è®¾è®¡' },
    'ç¾å›¢å¤–å–': { major: 'ç”Ÿæ´»æœåŠ¡', minor: 'å¤–å–é…é€' },
    'é¥¿äº†ä¹ˆå¤–å–': { major: 'ç”Ÿæ´»æœåŠ¡', minor: 'å¤–å–é…é€' },
    'ç¾å›¢ä¼˜é€‰': { major: 'ç”Ÿæ´»æœåŠ¡', minor: 'å¤–å–é…é€' },
    'å¤šå¤šä¹°èœ': { major: 'ç”Ÿæ´»æœåŠ¡', minor: 'å¤–å–é…é€' },
    'æ·˜é²œè¾¾': { major: 'ç”Ÿæ´»æœåŠ¡', minor: 'å¤–å–é…é€' },
    'ç™¾æœå›­': { major: 'ç¾é£Ÿé¤é¥®', minor: 'é£Ÿå“ç”Ÿé²œ' },
    'å®å’š': { major: 'ç”Ÿæ´»æœåŠ¡', minor: 'å¤–å–é…é€' },
    'æ¯æ—¥ä¼˜é²œ': { major: 'ç”Ÿæ´»æœåŠ¡', minor: 'å¤–å–é…é€' },
    'æ²ƒå°”ç›': { major: 'è´­ç‰©', minor: 'ç»¼åˆç”µå•†' },
    'å¥¥ä¹é½': { major: 'è´­ç‰©', minor: 'ç»¼åˆç”µå•†' },
    'ALDI': { major: 'è´­ç‰©', minor: 'ç»¼åˆç”µå•†' },
    'Costco': { major: 'è´­ç‰©', minor: 'ç»¼åˆç”µå•†' },
    'é±¼æ³¡ç›´è˜': { major: 'å•†åŠ¡åŠå…¬', minor: 'æ±‚èŒæ‹›è˜' },
    'é±¼æ³¡': { major: 'å•†åŠ¡åŠå…¬', minor: 'æ±‚èŒæ‹›è˜' },
    '233ä¹å›­': { major: 'æ¸¸æˆ', minor: 'ä¼‘é—²ç›Šæ™º' },
    'ç²‰ç¬”': { major: 'æ•™è‚²å­¦ä¹ ', minor: 'èŒä¸šåŸ¹è®­' },
    'ç²‰ç¬”æ•™è‚²': { major: 'æ•™è‚²å­¦ä¹ ', minor: 'èŒä¸šåŸ¹è®­' },
    'æ™ºå­¦ç½‘': { major: 'æ•™è‚²å­¦ä¹ ', minor: 'K12æ•™è‚²' },
    'æ»‘å‘—': { major: 'å¥èº«å¥åº·', minor: 'è¿åŠ¨å¥èº«' },
    'æ¯”äºšè¿ª': { major: 'æ±½è½¦æœåŠ¡', minor: 'ä¹°è½¦å–è½¦' },
    'BYD': { major: 'æ±½è½¦æœåŠ¡', minor: 'ä¹°è½¦å–è½¦' },
    'è‹±é›„è”ç›Ÿ': { major: 'æ¸¸æˆ', minor: 'MOBA' },
    'è‹±é›„è”ç›Ÿæ‰‹æ¸¸': { major: 'æ¸¸æˆ', minor: 'MOBA' },
    'LOL': { major: 'æ¸¸æˆ', minor: 'MOBA' },
    'è›‹ä»”æ´¾å¯¹': { major: 'æ¸¸æˆ', minor: 'ä¼‘é—²ç›Šæ™º' },
    'åœ°é“è·‘é…·': { major: 'æ¸¸æˆ', minor: 'ä¼‘é—²ç›Šæ™º' },
    'å¼€å¿ƒæ¶ˆæ¶ˆä¹': { major: 'æ¸¸æˆ', minor: 'ä¼‘é—²ç›Šæ™º' },
    'æ¬¢ä¹æ–—åœ°ä¸»': { major: 'æ¸¸æˆ', minor: 'æ£‹ç‰Œ' },
    'å¤©å¤©è±¡æ£‹': { major: 'æ¸¸æˆ', minor: 'æ£‹ç‰Œ' },
    'å…‰é‡': { major: 'æ¸¸æˆ', minor: 'RPG' },
    'å…ƒæ¢¦ä¹‹æ˜Ÿ': { major: 'æ¸¸æˆ', minor: 'ä¼‘é—²ç›Šæ™º' },
    'ç¬¬äº”äººæ ¼': { major: 'æ¸¸æˆ', minor: 'å›¢é˜Ÿç«æŠ€' },
    'é‡‘é“²é“²ä¹‹æˆ˜': { major: 'æ¸¸æˆ', minor: 'å›¢é˜Ÿç«æŠ€' },
    'ä¸‰å›½æ€': { major: 'æ¸¸æˆ', minor: 'æ£‹ç‰Œ' },
    'æ¢¦å¹»è¥¿æ¸¸': { major: 'æ¸¸æˆ', minor: 'RPG' },
    'é˜´é˜³å¸ˆ': { major: 'æ¸¸æˆ', minor: 'RPG' },
    'æš—åŒºçªå›´': { major: 'æ¸¸æˆ', minor: 'å°„å‡»' },
    'ç©¿è¶Šç«çº¿': { major: 'æ¸¸æˆ', minor: 'å°„å‡»' },
    'CF': { major: 'æ¸¸æˆ', minor: 'å°„å‡»' },
    'åˆºæ¿€æˆ˜åœº': { major: 'æ¸¸æˆ', minor: 'å°„å‡»' },
    'ç»åœ°æ±‚ç”Ÿ': { major: 'æ¸¸æˆ', minor: 'å°„å‡»' },
    'PUBG': { major: 'æ¸¸æˆ', minor: 'å°„å‡»' },
    'ä½¿å‘½å¬å”¤': { major: 'æ¸¸æˆ', minor: 'å°„å‡»' },
    'æ˜æ—¥æ–¹èˆŸ': { major: 'æ¸¸æˆ', minor: 'RPG' },
    'é€†æ°´å¯’': { major: 'æ¸¸æˆ', minor: 'RPG' },
    'è£è€€': { major: 'æ¸¸æˆ', minor: 'MOBA' },
    'æ‘©å¤©è½®': { major: 'å¨±ä¹', minor: 'OTT' },
    'æ‘©å¤©è½®ç¥¨åŠ¡': { major: 'å¨±ä¹', minor: 'OTT' },
    'é€†æˆ˜': { major: 'æ¸¸æˆ', minor: 'å°„å‡»' },
    'é€†æˆ˜åŠ©æ‰‹': { major: 'æ¸¸æˆ', minor: 'å°„å‡»' },
    'æ‰‹æœºå…¬ç§¯é‡‘': { major: 'é‡‘èç†è´¢', minor: 'å…¶ä»–' },
    'ima': { major: 'AI äººå·¥æ™ºèƒ½', minor: 'AIåŠ©æ‰‹' },
    'CADçœ‹å›¾': { major: 'å•†åŠ¡åŠå…¬', minor: 'åŠå…¬å·¥å…·' },
    'æ’•æ­Œ': { major: 'å¨±ä¹', minor: 'éŸ³ä¹ä¸éŸ³é¢‘' },
    'æ‰‡è´å•è¯': { major: 'æ•™è‚²å­¦ä¹ ', minor: 'è¯­è¨€å­¦ä¹ ' },
    'æ‰‡è´': { major: 'æ•™è‚²å­¦ä¹ ', minor: 'è¯­è¨€å­¦ä¹ ' },
  };

  // OCRå¸¸è§è¯¯è¯»åˆ«å â†’ æ­£ç¡®åç§°
  const OCR_ALIAS_MAP = {
    'DEBR-L': 'é©¬ä¸Šåˆ°å®¶',
    'DEBRL': 'é©¬ä¸Šåˆ°å®¶',
    'T-FAMI': 'å…¨å®¶',
    'TFAMI': 'å…¨å®¶',
    'T-FAM': 'å…¨å®¶',
    'TFAM': 'å…¨å®¶',
    'FAMILYMART': 'å…¨å®¶',
    'FamilyMart': 'å…¨å®¶',
    'Family': 'å…¨å®¶',
    'å…¨å®¶ä¾¿åˆ©': 'å…¨å®¶',
    'BOsSç›´è˜': 'BOSSç›´è˜',
    'Bossç›´è˜': 'BOSSç›´è˜',
    'bossç›´è˜': 'BOSSç›´è˜',
    'é“¾ å®¶': 'é“¾å®¶',
    'çŒª è˜': 'çŒè˜',
    'çŒ è˜': 'çŒè˜',
    'å¥½å¤§å¤«': 'å¥½å¤§å¤«åœ¨çº¿',
    'å¥½å¤§': 'å¥½å¤§å¤«åœ¨çº¿',
    'æµ·ä¿¡çˆ±': 'æµ·ä¿¡çˆ±å®¶',
    'å©šç¤¼': 'å©šç¤¼çºª',
    'æ‹›å•†é“¶': 'æ‹›å•†é“¶è¡Œ',
    'æ‹›å•†': 'æ‹›å•†é“¶è¡Œ',
    'éº¦å¾·': 'éº¦å¾·é¾™',
    'é©¬ä¸Šåˆ°': 'é©¬ä¸Šåˆ°å®¶',
    'å¹´è´§': 'å¹´è´§èŠ‚',
    'é±¼æ³¡': 'é±¼æ³¡ç›´è˜',
    'é±¼æ³¡ç›´è˜': 'é±¼æ³¡ç›´è˜',
    '233ä¹å›­': '233ä¹å›­',
    '233': '233ä¹å›­',
    'æ™ºå­¦ç½‘': 'æ™ºå­¦ç½‘',
    'æ™ºå­¦': 'æ™ºå­¦ç½‘',
    'ç²‰ç¬”': 'ç²‰ç¬”',
    'æ»‘å‘—': 'æ»‘å‘—',
    'æ»‘ å‘—': 'æ»‘å‘—',
    'æ¯”äºšè¿ª': 'æ¯”äºšè¿ª',
    'BYD': 'æ¯”äºšè¿ª',
    'BmMm': 'æ¯”äºšè¿ª',
    'é€†æˆ˜åŠ©': 'é€†æˆ˜åŠ©æ‰‹',
    'æ‘©å¤©': 'æ‘©å¤©è½®',
    'æ‰‹æœºå…¬ç§¯': 'æ‰‹æœºå…¬ç§¯é‡‘',
    'å…¬ç§¯é‡‘': 'æ‰‹æœºå…¬ç§¯é‡‘',
    'CAD': 'CADçœ‹å›¾',
    'æ‰‡è´å•': 'æ‰‡è´å•è¯',
    'æ‰‡ è´': 'æ‰‡è´',
    'åå¤é“¶': 'åå¤é“¶è¡Œ',
    'åå¤': 'åå¤é“¶è¡Œ',
  };

  function matchCategory(name) {
    if (!name) return { major: '', minor: '' };
    // ç²¾ç¡®åŒ¹é…
    if (APP_NAME_CATEGORY_MAP[name]) return { ...APP_NAME_CATEGORY_MAP[name] };
    // æ¨¡ç³ŠåŒ¹é…ï¼ˆåç§°åŒ…å«å…³é”®è¯ï¼‰
    for (const [key, cat] of Object.entries(APP_NAME_CATEGORY_MAP)) {
      if (name.includes(key) || key.includes(name)) return { ...cat };
    }
    return { major: '', minor: '' };
  }

  // ============ äº§å“ + åŒºåŸŸ æ‰¹é‡é€‰æ‹© ============
  document.querySelectorAll('#productOptions .product-btn').forEach(btn => {
    btn.addEventListener('click', () => {
      document.querySelectorAll('#productOptions .product-btn').forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
      currentProduct = btn.dataset.product;
    });
  });

  let currentRegion = 'ä¸­å›½å¤§é™†'; // å…¨å±€å½“å‰é€‰ä¸­çš„åŒºåŸŸ
  document.querySelectorAll('#regionOptions .region-btn').forEach(btn => {
    btn.addEventListener('click', () => {
      document.querySelectorAll('#regionOptions .region-btn').forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
      currentRegion = btn.dataset.region;
    });
  });

  // ============ Tab åˆ‡æ¢ ============
  document.querySelectorAll('.tab-btn').forEach(btn => {
    btn.addEventListener('click', () => {
      document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
      document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
      btn.classList.add('active');
      document.getElementById('tab-' + btn.dataset.tab).classList.add('active');
    });
  });

  // ============ æ¨¡å¼ä¸€ï¼šæˆªå›¾è£å‰ª ============
  const cropUploadArea = document.getElementById('cropUploadArea');
  const cropFileInput = document.getElementById('cropFileInput');
  const cropWorkspace = document.getElementById('cropWorkspace');
  const cropImage = document.getElementById('cropImage');
  const cropContainer = document.getElementById('cropContainer');
  const cropSelectionOverlay = document.getElementById('cropSelectionOverlay');
  const cropRectEl = document.getElementById('cropRect');
  const cropList = document.getElementById('cropList');
  const cropCountEl = document.getElementById('cropCount');

  let cropItems = [];
  let isCropping = false;
  let cropStartX = 0, cropStartY = 0;

  cropUploadArea.addEventListener('click', () => cropFileInput.click());
  setupDragDrop(cropUploadArea, cropFileInput);

  cropFileInput.addEventListener('change', (e) => {
    if (e.target.files[0]) loadCropImage(e.target.files[0]);
    e.target.value = '';
  });

  function loadCropImage(file) {
    const reader = new FileReader();
    reader.onload = (e) => {
      cropImage.src = e.target.result;
      cropImage.onload = () => {
        cropWorkspace.classList.add('visible');
        updateGenerateBar();
      };
    };
    reader.readAsDataURL(file);
  }

  // æ¡†é€‰è£å‰ª â€” ç”¨ div å®ç°é€‰åŒº
  cropSelectionOverlay.addEventListener('mousedown', (e) => {
    e.preventDefault();
    e.stopPropagation();
    const containerRect = cropContainer.getBoundingClientRect();
    cropStartX = e.clientX - containerRect.left;
    cropStartY = e.clientY - containerRect.top;
    isCropping = true;

    cropRectEl.style.left = cropStartX + 'px';
    cropRectEl.style.top = cropStartY + 'px';
    cropRectEl.style.width = '0px';
    cropRectEl.style.height = '0px';
    cropRectEl.style.display = 'block';
  });

  document.addEventListener('mousemove', (e) => {
    if (!isCropping) return;
    e.preventDefault();
    const containerRect = cropContainer.getBoundingClientRect();
    const curX = Math.max(0, Math.min(e.clientX - containerRect.left, cropImage.clientWidth));
    const curY = Math.max(0, Math.min(e.clientY - containerRect.top, cropImage.clientHeight));

    const x = Math.min(cropStartX, curX);
    const y = Math.min(cropStartY, curY);
    const w = Math.abs(curX - cropStartX);
    const h = Math.abs(curY - cropStartY);

    cropRectEl.style.left = x + 'px';
    cropRectEl.style.top = y + 'px';
    cropRectEl.style.width = w + 'px';
    cropRectEl.style.height = h + 'px';
  });

  document.addEventListener('mouseup', (e) => {
    if (!isCropping) return;
    isCropping = false;

    const x = parseInt(cropRectEl.style.left) || 0;
    const y = parseInt(cropRectEl.style.top) || 0;
    const w = parseInt(cropRectEl.style.width) || 0;
    const h = parseInt(cropRectEl.style.height) || 0;

    cropRectEl.style.display = 'none';

    if (w > 10 && h > 10) {
      extractCropRegion({ x, y, w, h });
    }
  });

  // ============ æ™ºèƒ½è¯†åˆ«æ‰€æœ‰ Logo ============
  document.getElementById('autoDetectBtn').addEventListener('click', autoDetectLogos);

  function autoDetectLogos() {
    if (!cropImage.src || !cropImage.naturalWidth) {
      alert('è¯·å…ˆä¸Šä¼ æˆªå›¾');
      return;
    }

    const btn = document.getElementById('autoDetectBtn');
    const status = document.getElementById('autoDetectStatus');
    btn.disabled = true;
    btn.textContent = 'è¯†åˆ«ä¸­...';
    status.textContent = 'æ­£åœ¨åˆ†æå›¾ç‰‡...';

    setTimeout(() => { doAutoDetect(btn, status); }, 50);
  }

  function doAutoDetect(btn, status) {
    const natW = cropImage.naturalWidth;
    const natH = cropImage.naturalHeight;
    const dispW = cropImage.clientWidth;
    const dispH = cropImage.clientHeight;

    const canvas = document.createElement('canvas');
    canvas.width = natW;
    canvas.height = natH;
    const ctx = canvas.getContext('2d');
    ctx.drawImage(cropImage, 0, 0);
    const imgData = ctx.getImageData(0, 0, natW, natH);
    const px = imgData.data;

    function getP(x, y) {
      if (x < 0 || x >= natW || y < 0 || y >= natH) return [255, 255, 255];
      const i = (y * natW + x) * 4;
      return [px[i], px[i+1], px[i+2]];
    }

    // é¡µé¢çº¯ç™½èƒŒæ™¯
    function isBg(r, g, b) {
      return (r > 240 && g > 240 && b > 240);
    }

    // ç°è‰²è¾¹æ¡†çº¿æ£€æµ‹ï¼ˆLogoåœ†è§’æ­£æ–¹å½¢çš„ç»†ç°çº¿ï¼Œé€šå¸¸æ˜¯ 200~240 ç°åº¦ï¼‰
    function isGrayBorder(r, g, b) {
      const gray = r * 0.299 + g * 0.587 + b * 0.114;
      const maxDiff = Math.max(Math.abs(r - g), Math.abs(g - b), Math.abs(r - b));
      return gray >= 180 && gray <= 240 && maxDiff < 20;
    }

    // éçº¯ç™½å†…å®¹ï¼ˆåŒ…æ‹¬ç°è‰²è¾¹æ¡†ï¼‰
    function isContent(r, g, b) {
      return !isBg(r, g, b);
    }

    // ===== è¡Œåˆ†éš”æ£€æµ‹ =====
    const rowBgRatio = [];
    for (let y = 0; y < natH; y++) {
      let bgCount = 0;
      const step = Math.max(1, Math.floor(natW / 200));
      let samples = 0;
      for (let x = 0; x < natW; x += step) {
        const [r, g, b] = getP(x, y);
        if (isBg(r, g, b)) bgCount++;
        samples++;
      }
      rowBgRatio.push(bgCount / samples);
    }

    const bgThreshold = 0.95;
    const bands = [];
    let bandStart = -1;
    for (let y = 0; y < natH; y++) {
      if (rowBgRatio[y] < bgThreshold) {
        if (bandStart === -1) bandStart = y;
      } else {
        if (bandStart !== -1) {
          const h = y - bandStart;
          if (h > 30) {
            bands.push({ top: bandStart, bottom: y, h });
          }
          bandStart = -1;
        }
      }
    }
    if (bandStart !== -1) {
      const h = natH - bandStart;
      if (h > 30) bands.push({ top: bandStart, bottom: natH, h });
    }

    if (bands.length === 0) {
      status.textContent = 'æœªæ£€æµ‹åˆ°è¡Œç»“æ„ï¼Œè¯·å°è¯•æ‰‹åŠ¨æ¡†é€‰';
      btn.disabled = false;
      btn.textContent = 'æ™ºèƒ½è¯†åˆ«æ‰€æœ‰ Logo';
      return;
    }

    // ===== æ¯è¡Œå·¦ä¾§æ‰¾Logoå›¾æ ‡ =====
    const detectedLogos = [];

    bands.forEach(band => {
      const bandH = band.h;
      const scanW = Math.floor(natW * 0.4);

      // æ‰¾å†…å®¹å¼€å§‹çš„xï¼ˆåŒ…æ‹¬ç°è‰²è¾¹æ¡†çº¿ï¼‰
      let contentStartX = -1;
      for (let x = 0; x < scanW; x++) {
        let nonBgInCol = 0;
        const stepY = Math.max(1, Math.floor(bandH / 50));
        let total = 0;
        for (let y = band.top; y < band.bottom; y += stepY) {
          const [r, g, b] = getP(x, y);
          if (isContent(r, g, b)) nonBgInCol++;
          total++;
        }
        if (nonBgInCol / total > 0.08) {
          contentStartX = x;
          break;
        }
      }

      if (contentStartX === -1) return;

      // æ‰¾å‚ç›´è¾¹ç•Œ
      let topY = band.bottom, bottomY = band.top;
      for (let y = band.top; y < band.bottom; y++) {
        for (let x = contentStartX; x < Math.min(contentStartX + scanW, natW); x += 2) {
          const [r, g, b] = getP(x, y);
          if (isContent(r, g, b)) {
            if (y < topY) topY = y;
            if (y > bottomY) bottomY = y;
            break;
          }
        }
      }

      const contentH = bottomY - topY;
      if (contentH < 20) return;

      // åˆ—å†…å®¹æ£€æµ‹ï¼ˆåŒ…æ‹¬ç°è‰²è¾¹æ¡†ï¼‰
      const colHasContent = [];
      for (let x = contentStartX; x < scanW; x++) {
        let nonBg = 0;
        let total = 0;
        for (let y = topY; y <= bottomY; y += 2) {
          const [r, g, b] = getP(x, y);
          if (isContent(r, g, b)) nonBg++;
          total++;
        }
        colHasContent.push(nonBg / Math.max(total, 1) > 0.06);
      }

      // æ‰¾ç¬¬ä¸€ä¸ªå†…å®¹å—
      let logoStartX = -1, logoEndX = -1;
      let gapCount = 0;
      const maxGap = 6;
      
      for (let i = 0; i < colHasContent.length; i++) {
        if (colHasContent[i]) {
          if (logoStartX === -1) logoStartX = i;
          logoEndX = i;
          gapCount = 0;
        } else {
          if (logoStartX !== -1) {
            gapCount++;
            if (gapCount > maxGap) break;
          }
        }
      }

      if (logoStartX === -1) return;

      const logoX = contentStartX + logoStartX;
      const logoRight = contentStartX + logoEndX;
      const logoW = logoRight - logoX;

      if (logoW < 20) return;

      // ç²¾ç»†åŒ–è¾¹ç•Œï¼ˆåŒ…æ‹¬ç°è‰²è¾¹æ¡†çº¿ï¼‰
      let fMinX = logoRight, fMaxX = logoX, fMinY = bottomY, fMaxY = topY;
      for (let y = topY; y <= bottomY; y++) {
        for (let x = logoX; x <= logoRight; x++) {
          const [r, g, b] = getP(x, y);
          if (isContent(r, g, b)) {
            if (x < fMinX) fMinX = x;
            if (x > fMaxX) fMaxX = x;
            if (y < fMinY) fMinY = y;
            if (y > fMaxY) fMaxY = y;
          }
        }
      }

      let finalW = fMaxX - fMinX;
      let finalH = fMaxY - fMinY;
      if (finalW < 20 || finalH < 20) return;

      // ===== å…³é”®æ”¹è¿›ï¼šæ£€æµ‹ç°è‰²è¾¹æ¡†æ¥æ‰©å±•Logoè¾¹ç•Œ =====
      // å¦‚æœæ£€æµ‹åˆ°çš„å†…å®¹è¾¹ç•Œé™„è¿‘æœ‰ç°è‰²è¾¹æ¡†çº¿ï¼Œè¯´æ˜Logoæœ‰ç™½è‰²èƒŒæ™¯+ç°è‰²è¾¹æ¡†
      // éœ€è¦ä»ç°è‰²è¾¹æ¡†å‘å†…æ‰«æï¼ŒæŠŠæ•´ä¸ªåœ†è§’çŸ©å½¢åŒ…å«è¿›æ¥
      
      // æ£€æŸ¥å››å‘¨æ˜¯å¦æœ‰ç°è‰²è¾¹æ¡†
      let hasGrayBorder = false;
      const borderCheckRange = 3; // æ£€æŸ¥è¾¹ç•Œé™„è¿‘3px
      
      // æ£€æŸ¥é¡¶è¾¹
      for (let x = fMinX; x <= fMaxX; x += Math.max(1, Math.floor(finalW / 20))) {
        for (let dy = -borderCheckRange; dy <= borderCheckRange; dy++) {
          const [r, g, b] = getP(x, fMinY + dy);
          if (isGrayBorder(r, g, b)) { hasGrayBorder = true; break; }
        }
        if (hasGrayBorder) break;
      }
      if (!hasGrayBorder) {
        // æ£€æŸ¥å·¦è¾¹
        for (let y = fMinY; y <= fMaxY; y += Math.max(1, Math.floor(finalH / 20))) {
          for (let dx = -borderCheckRange; dx <= borderCheckRange; dx++) {
            const [r, g, b] = getP(fMinX + dx, y);
            if (isGrayBorder(r, g, b)) { hasGrayBorder = true; break; }
          }
          if (hasGrayBorder) break;
        }
      }

      if (hasGrayBorder) {
        // æœ‰ç°è‰²è¾¹æ¡† â€” ä»è¾¹æ¡†å¤–æ‰©ï¼Œæ‰¾åˆ°å®Œæ•´çš„åœ†è§’çŸ©å½¢
        // æ–¹æ³•ï¼šä»å½“å‰è¾¹ç•Œå‘å¤–æ‰©å±•ï¼Œç›´åˆ°æ‰¾ä¸åˆ°ç°è‰²è¾¹æ¡†çº¿
        const expandMax = 15;
        
        // å‘ä¸Šæ‰©å±•
        for (let dy = 1; dy <= expandMax; dy++) {
          let foundBorder = false;
          for (let x = fMinX; x <= fMaxX; x += Math.max(1, Math.floor(finalW / 30))) {
            const [r, g, b] = getP(x, fMinY - dy);
            if (isGrayBorder(r, g, b) || !isBg(r, g, b)) { foundBorder = true; break; }
          }
          if (foundBorder) fMinY -= 1;
          else break;
        }
        // å‘ä¸‹æ‰©å±•
        for (let dy = 1; dy <= expandMax; dy++) {
          let foundBorder = false;
          for (let x = fMinX; x <= fMaxX; x += Math.max(1, Math.floor(finalW / 30))) {
            const [r, g, b] = getP(x, fMaxY + dy);
            if (isGrayBorder(r, g, b) || !isBg(r, g, b)) { foundBorder = true; break; }
          }
          if (foundBorder) fMaxY += 1;
          else break;
        }
        // å‘å·¦æ‰©å±•
        for (let dx = 1; dx <= expandMax; dx++) {
          let foundBorder = false;
          for (let y = fMinY; y <= fMaxY; y += Math.max(1, Math.floor(finalH / 30))) {
            const [r, g, b] = getP(fMinX - dx, y);
            if (isGrayBorder(r, g, b) || !isBg(r, g, b)) { foundBorder = true; break; }
          }
          if (foundBorder) fMinX -= 1;
          else break;
        }
        // å‘å³æ‰©å±•
        for (let dx = 1; dx <= expandMax; dx++) {
          let foundBorder = false;
          for (let y = fMinY; y <= fMaxY; y += Math.max(1, Math.floor(finalH / 30))) {
            const [r, g, b] = getP(fMaxX + dx, y);
            if (isGrayBorder(r, g, b) || !isBg(r, g, b)) { foundBorder = true; break; }
          }
          if (foundBorder) fMaxX += 1;
          else break;
        }
        
        finalW = fMaxX - fMinX;
        finalH = fMaxY - fMinY;
      }

      // å–æ–¹å½¢
      const cx = (fMinX + fMaxX) / 2;
      const cy = (fMinY + fMaxY) / 2;
      const size = Math.max(finalW, finalH);
      const aspect = Math.min(finalW, finalH) / Math.max(finalW, finalH);
      if (aspect < 0.45) return;

      detectedLogos.push({
        cx, cy, size, w: finalW, h: finalH
      });
    });

    if (detectedLogos.length === 0) {
      status.textContent = 'æœªæ£€æµ‹åˆ°Logoå›¾æ ‡ï¼Œè¯·å°è¯•æ‰‹åŠ¨æ¡†é€‰';
      btn.disabled = false;
      btn.textContent = 'æ™ºèƒ½è¯†åˆ«æ‰€æœ‰ Logo';
      return;
    }

    // Step 3: ç»Ÿä¸€Logoå°ºå¯¸
    const sizes = detectedLogos.map(l => l.size).sort((a, b) => a - b);
    const medianSize = sizes[Math.floor(sizes.length / 2)];

    const filtered = detectedLogos.filter(l => {
      return l.size > medianSize * 0.5 && l.size < medianSize * 1.8;
    });

    if (filtered.length === 0) {
      status.textContent = 'æœªæ£€æµ‹åˆ°Logoï¼Œè¯·å°è¯•æ‰‹åŠ¨æ¡†é€‰';
      btn.disabled = false;
      btn.textContent = 'æ™ºèƒ½è¯†åˆ«æ‰€æœ‰ Logo';
      return;
    }

    // ===== å»é‡ï¼šå¦‚æœä¸¤ä¸ªLogoä¸­å¿ƒç‚¹è·ç¦»å¤ªè¿‘ï¼Œåªä¿ç•™ä¸€ä¸ª =====
    const deduped = [];
    const minDist = medianSize * 0.5; // ä¸­å¿ƒè·ç¦»å°äºåŠä¸ªLogoå°ºå¯¸çš„è§†ä¸ºé‡å¤
    filtered.forEach(logo => {
      const isDup = deduped.some(existing => {
        const dx = logo.cx - existing.cx;
        const dy = logo.cy - existing.cy;
        return Math.sqrt(dx * dx + dy * dy) < minDist;
      });
      if (!isDup) deduped.push(logo);
    });

    const uniformSize = medianSize;
    const pad = Math.ceil(uniformSize * 0.08);

    const finalLogos = deduped.map(logo => {
      const half = Math.ceil(uniformSize / 2) + pad;
      return {
        x: Math.max(0, Math.floor(logo.cx - half)),
        y: Math.max(0, Math.floor(logo.cy - half)),
        w: Math.min(half * 2, natW),
        h: Math.min(half * 2, natH)
      };
    });

    status.textContent = `æ£€æµ‹åˆ° ${finalLogos.length} ä¸ª Logoï¼Œæ­£åœ¨è£å‰ªå¹¶è¯†åˆ«...`;

    const scaleX = dispW / natW;
    const scaleY = dispH / natH;

    let processed = 0;
    finalLogos.forEach((logo, i) => {
      const displayRect = {
        x: logo.x * scaleX,
        y: logo.y * scaleY,
        w: logo.w * scaleX,
        h: logo.h * scaleY
      };
      // æ‰¾åˆ°è¯¥Logoæ‰€åœ¨çš„bandï¼Œä¼ é€’æ•´è¡Œä¿¡æ¯ç”¨äºåˆ†ç±»åŒºåŸŸè£å‰ª
      const logoCY = logo.y + logo.h / 2;
      let matchedBand = null;
      for (const band of bands) {
        if (logoCY >= band.top && logoCY <= band.bottom) {
          matchedBand = band;
          break;
        }
      }
      setTimeout(() => {
        extractCropRegion(displayRect, matchedBand);
        processed++;
        if (processed === finalLogos.length) {
          status.textContent = `å®Œæˆï¼å…±è¯†åˆ« ${finalLogos.length} ä¸ª Logo`;
          btn.disabled = false;
          btn.textContent = 'æ™ºèƒ½è¯†åˆ«æ‰€æœ‰ Logo';
        }
      }, i * 300);
    });
  }

  // è‡ªåŠ¨è£åˆ‡ç™½è¾¹
  function trimWhiteBorder(canvas) {
    const ctx = canvas.getContext('2d');
    const w = canvas.width, h = canvas.height;
    const imgData = ctx.getImageData(0, 0, w, h);
    const px = imgData.data;

    function isWhite(x, y) {
      const i = (y * w + x) * 4;
      return px[i] > 240 && px[i+1] > 240 && px[i+2] > 240;
    }

    let top = 0, bottom = h - 1, left = 0, right = w - 1;

    // ä»ä¸Šå‘ä¸‹æ‰¾
    outer1: for (let y = 0; y < h; y++) {
      for (let x = 0; x < w; x += 2) {
        if (!isWhite(x, y)) { top = y; break outer1; }
      }
    }
    // ä»ä¸‹å‘ä¸Šæ‰¾
    outer2: for (let y = h - 1; y >= top; y--) {
      for (let x = 0; x < w; x += 2) {
        if (!isWhite(x, y)) { bottom = y; break outer2; }
      }
    }
    // ä»å·¦å‘å³æ‰¾
    outer3: for (let x = 0; x < w; x++) {
      for (let y = top; y <= bottom; y += 2) {
        if (!isWhite(x, y)) { left = x; break outer3; }
      }
    }
    // ä»å³å‘å·¦æ‰¾
    outer4: for (let x = w - 1; x >= left; x--) {
      for (let y = top; y <= bottom; y += 2) {
        if (!isWhite(x, y)) { right = x; break outer4; }
      }
    }

    const cw = right - left + 1;
    const ch = bottom - top + 1;

    // å¦‚æœè£åˆ‡åé¢ç§¯å¤ªå°ï¼ˆ< åŸé¢ç§¯30%ï¼‰ï¼Œåˆ™ä¸è£
    if (cw * ch < w * h * 0.3) return canvas;

    // åŠ å°‘é‡paddingï¼ˆ2pxï¼‰
    const pad = 2;
    const fx = Math.max(0, left - pad);
    const fy = Math.max(0, top - pad);
    const fw = Math.min(w - fx, cw + pad * 2);
    const fh = Math.min(h - fy, ch + pad * 2);

    // ç”Ÿæˆæ­£æ–¹å½¢ï¼ˆå±…ä¸­ï¼‰
    const size = Math.max(fw, fh);
    const out = document.createElement('canvas');
    out.width = size;
    out.height = size;
    const octx = out.getContext('2d');
    octx.fillStyle = '#ffffff';
    octx.fillRect(0, 0, size, size);
    const ox = Math.floor((size - fw) / 2);
    const oy = Math.floor((size - fh) / 2);
    octx.drawImage(canvas, fx, fy, fw, fh, ox, oy, fw, fh);
    return out;
  }

  function extractCropRegion(rect, bandInfo) {
    const scaleX = cropImage.naturalWidth / cropImage.clientWidth;
    const scaleY = cropImage.naturalHeight / cropImage.clientHeight;

    // è£å‰ª Logo å›¾ç‰‡
    const canvas = document.createElement('canvas');
    canvas.width = rect.w * scaleX;
    canvas.height = rect.h * scaleY;
    const ctx = canvas.getContext('2d');
    ctx.drawImage(cropImage,
      rect.x * scaleX, rect.y * scaleY, rect.w * scaleX, rect.h * scaleY,
      0, 0, canvas.width, canvas.height
    );

    // è‡ªåŠ¨è£åˆ‡ç™½è¾¹ï¼Œè®©Logoå±…ä¸­
    const trimmed = trimWhiteBorder(canvas);
    const src = trimmed.toDataURL('image/png');
    const index = cropItems.length;
    cropItems.push({ src, name: 'è¯†åˆ«ä¸­...', category: 'è¯†åˆ«ä¸­...', subcategory: '', product: currentProduct, region: currentRegion, ocrDone: false });
    renderCropList();
    updateGenerateBar();

    // ===== OCRè¯†åˆ«Appåç§° =====
    const logoNatW = rect.w * scaleX;
    const logoNatH = rect.h * scaleY;
    const logoNatX = rect.x * scaleX;
    const logoNatY = rect.y * scaleY;
    
    // åç§°åŒºåŸŸï¼šLogoå³ä¾§ï¼Œå®½åº¦å– Logoå®½åº¦Ã—3 æˆ–åˆ°å›¾ç‰‡45%å¤„ï¼ˆå–è¾ƒå¤§å€¼ç¡®ä¿ä¸ä¸ºè´Ÿï¼‰
    const nameX = logoNatX + logoNatW + 5;
    const nameY = bandInfo ? bandInfo.top : logoNatY;
    const nameRightLimit = Math.max(cropImage.naturalWidth * 0.45, logoNatX + logoNatW + logoNatW * 2);
    const nameW = Math.max(logoNatW * 1.5, Math.min(logoNatW * 4, nameRightLimit - nameX));
    const nameH = bandInfo ? (bandInfo.bottom - bandInfo.top) : logoNatH;

    // åˆ†ç±»åŒºåŸŸï¼šä½¿ç”¨bandä¿¡æ¯ï¼ˆæ•´è¡Œï¼‰æ¥ç²¾ç¡®ç¡®å®šåˆ†ç±»æ ‡ç­¾ä½ç½®
    // åˆ†ç±»æ ‡ç­¾é€šå¸¸åœ¨æ•´è¡Œçš„å³ä¾§50%åŒºåŸŸï¼ˆä»å›¾ç‰‡ä¸­é—´åˆ°å³è¾¹ï¼‰
    let catX, catY, catW, catH;
    if (bandInfo) {
      // æœ‰bandä¿¡æ¯ï¼šä½¿ç”¨æ•´è¡Œçš„å³åŠéƒ¨åˆ†ä½œä¸ºåˆ†ç±»åŒºåŸŸ
      const bandMidX = Math.floor(cropImage.naturalWidth * 0.45); // ä»45%å¤„å¼€å§‹
      catX = bandMidX;
      catY = bandInfo.top;
      catW = cropImage.naturalWidth - bandMidX;
      catH = bandInfo.bottom - bandInfo.top;
    } else {
      // æ— bandä¿¡æ¯ï¼šfallbackåˆ°åŸºäºLogoä½ç½®çš„ä¼°ç®—
      const catRegionW = Math.floor(cropImage.naturalWidth * 0.50);
      catX = cropImage.naturalWidth - catRegionW;
      const catPadY = Math.floor(logoNatH * 0.25);
      catY = Math.max(0, logoNatY - catPadY);
      catW = catRegionW;
      catH = Math.min(logoNatH + catPadY * 2, cropImage.naturalHeight - catY);
    }

    function cleanOcrText(raw) {
      if (!raw) return '';
      let cleaned = raw.replace(/([\u4e00-\u9fa5])\s+([\u4e00-\u9fa5])/g, '$1$2');
      cleaned = cleaned.replace(/([\u4e00-\u9fa5])\s+([\u4e00-\u9fa5])/g, '$1$2');
      cleaned = cleaned.replace(/([\u4e00-\u9fa5])\s+(\d)/g, '$1$2');
      cleaned = cleaned.replace(/(\d)\s+([\u4e00-\u9fa5])/g, '$1$2');
      cleaned = cleaned.replace(/([\u4e00-\u9fa5])\s+([a-zA-Z])/g, '$1$2');
      cleaned = cleaned.replace(/([a-zA-Z])\s+([\u4e00-\u9fa5])/g, '$1$2');
      cleaned = cleaned.replace(/\s{2,}/g, ' ');
      cleaned = cleaned.trim();
      cleaned = cleaned.replace(/[|\\\/\[\]{}()ï¼ˆï¼‰<>ã€Šã€‹ã€Œã€ã€ã€‘~`^*#@$%&+=ã€‚ï¼Œã€ï¼›ï¼šï¼Ÿï¼""''â€¦â€”Â·â€¢]+/g, '');
      cleaned = cleaned.replace(/\.{2,}/g, '');
      return cleaned.trim();
    }

    function correctOcrName(ocrName) {
      if (!ocrName || ocrName.length < 1) return ocrName;

      // 0. ç›´æ¥åŒ¹é…åˆ«åæ˜ å°„è¡¨ï¼ˆä¼˜å…ˆçº§æœ€é«˜ï¼‰
      if (OCR_ALIAS_MAP[ocrName]) return OCR_ALIAS_MAP[ocrName];
      // å¤§å°å†™ä¸æ•æ„ŸåŒ¹é…åˆ«å
      const upperName = ocrName.toUpperCase();
      for (const [alias, correct] of Object.entries(OCR_ALIAS_MAP)) {
        if (alias.toUpperCase() === upperName) return correct;
      }
      // åˆ«ååŒ…å«æ£€æŸ¥ï¼ˆè¦æ±‚è‡³å°‘3ä¸ªå­—ç¬¦æ‰åšåŒ…å«åŒ¹é…ï¼Œé¿å…çŸ­å­—ç¬¦ä¸²è¯¯åŒ¹é…ï¼‰
      for (const [alias, correct] of Object.entries(OCR_ALIAS_MAP)) {
        if (ocrName.length >= 2 && ocrName.includes(alias) && alias.length >= 2) return correct;
        if (alias.length >= 3 && alias.includes(ocrName) && ocrName.length >= 2) return correct;
      }

      // 1. ç²¾ç¡®åŒ¹é…å·²çŸ¥åç§°
      const knownNames = Object.keys(APP_NAME_CATEGORY_MAP);
      if (knownNames.includes(ocrName)) return ocrName;

      // 2. åŒ…å«å…³ç³»åŒ¹é…
      for (const known of knownNames) {
        if (ocrName.includes(known)) return known;
        if (known.includes(ocrName) && ocrName.length >= 2) return known;
      }

      // 3. ç¼–è¾‘è·ç¦»çº é”™ï¼ˆæ”¶ç´§é˜ˆå€¼ï¼Œé¿å…è¯¯åŒ¹é…ï¼‰
      let bestMatch = ocrName;
      let bestDist = Infinity;
      for (const known of knownNames) {
        if (Math.abs(known.length - ocrName.length) > 2) continue;
        const dist = editDistance(ocrName, known);
        const threshold = known.length <= 2 ? 0 : (known.length <= 4 ? 1 : 2);
        if (dist <= threshold && dist < bestDist) {
          bestDist = dist;
          bestMatch = known;
        }
      }
      return bestMatch;
    }

    function editDistance(a, b) {
      const m = a.length, n = b.length;
      const dp = Array.from({length: m + 1}, () => Array(n + 1).fill(0));
      for (let i = 0; i <= m; i++) dp[i][0] = i;
      for (let j = 0; j <= n; j++) dp[0][j] = j;
      for (let i = 1; i <= m; i++) {
        for (let j = 1; j <= n; j++) {
          dp[i][j] = a[i-1] === b[j-1] ? dp[i-1][j-1] : Math.min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1]) + 1;
        }
      }
      return dp[m][n];
    }

    // ä»OCRæ–‡æœ¬ä¸­æå– "å¤§åˆ†ç±» > å°åˆ†ç±»" æ ¼å¼
    function extractCategoryFromOcr(text) {
      if (!text) return null;
      // é¢„å¤„ç†ï¼šåˆå¹¶ä¸­æ–‡å­—ç¬¦é—´çš„ç©ºæ ¼ï¼ˆOCRå¸¸è§é—®é¢˜ï¼‰
      let preprocessed = text.replace(/([\u4e00-\u9fa5])\s+([\u4e00-\u9fa5])/g, '$1$2');
      preprocessed = preprocessed.replace(/([\u4e00-\u9fa5])\s+([\u4e00-\u9fa5])/g, '$1$2');
      // å†æ¬¡åˆå¹¶ï¼ˆå¤„ç†3ä¸ªå­—è¢«æ‹†å¼€çš„æƒ…å†µï¼‰
      preprocessed = preprocessed.replace(/([\u4e00-\u9fa5])\s+([\u4e00-\u9fa5])/g, '$1$2');
      // åˆå¹¶æ‰€æœ‰æ–‡æœ¬ï¼ˆæœ‰æ—¶åˆ†ç±»è¢«æ‹†æˆå¤šè¡Œï¼‰
      const rawText = preprocessed.replace(/\n+/g, ' ').replace(/\s{2,}/g, ' ').trim();
      const lines = preprocessed.split('\n').map(l => l.trim()).filter(l => l);

      // æ‰€æœ‰å°åˆ†ç±»å±•å¹³ç”¨äºç›´æ¥æœç´¢
      const allMinors = {};
      for (const [maj, subs] of Object.entries(CATEGORY_TREE)) {
        subs.forEach(sub => { allMinors[sub] = maj; });
      }

      // éªŒè¯å¤§åˆ†ç±»æ˜¯å¦å­˜åœ¨äºCATEGORY_TREEï¼ˆæ›´å®½æ¾åŒ¹é…ï¼‰
      function isValidMajor(name) {
        if (!name) return false;
        if (CATEGORY_TREE[name]) return true;
        for (const cat of MAJOR_CATEGORIES) {
          if (cat.includes(name) || name.includes(cat)) return true;
          if (name.length >= 2 && editDistance(name, cat) <= 2) return true;
        }
        return false;
      }

      // ä¿®æ­£å¤§åˆ†ç±»åç§°ï¼ˆæ›´å®½æ¾åŒ¹é…ï¼‰
      function fixMajor(name) {
        if (CATEGORY_TREE[name]) return name;
        let best = name, bestDist = Infinity;
        for (const cat of MAJOR_CATEGORIES) {
          if (cat === name) return cat;
          if (cat.includes(name) || name.includes(cat)) return cat;
          const d = editDistance(name, cat);
          if (d <= 2 && d < bestDist) { bestDist = d; best = cat; }
        }
        return best;
      }

      // ä¿®æ­£å°åˆ†ç±»åç§°ï¼ˆæ›´å®½æ¾åŒ¹é…ï¼‰
      function fixMinor(major, minor) {
        if (!major || !CATEGORY_TREE[major]) return minor;
        const subs = CATEGORY_TREE[major];
        if (subs.includes(minor)) return minor;
        let best = minor, bestDist = Infinity;
        for (const sub of subs) {
          if (sub.includes(minor) || minor.includes(sub)) return sub;
          const d = editDistance(minor, sub);
          if (d <= 2 && d < bestDist) { bestDist = d; best = sub; }
        }
        return best;
      }

      // ç­–ç•¥0ï¼šæ£€æŸ¥OCRæ–‡æœ¬ä¸­æ˜¯å¦ç›´æ¥åŒ…å« "å¤§åˆ†ç±»å°åˆ†ç±»"ï¼ˆåˆ†éš”ç¬¦è¢«åæ‰çš„æƒ…å†µï¼‰
      // ä¾‹å¦‚ OCRè¯†åˆ«æˆ "é‡‘èç†è´¢é“¶è¡Œ" æˆ– "æ¸¸æˆå°„å‡»"
      const cleanedAll = rawText.replace(/[^a-zA-Z\u4e00-\u9fa5]/g, '');
      for (const cat of MAJOR_CATEGORIES) {
        const idx = cleanedAll.indexOf(cat);
        if (idx !== -1) {
          const afterCat = cleanedAll.substring(idx + cat.length);
          if (CATEGORY_TREE[cat]) {
            for (const sub of CATEGORY_TREE[cat]) {
              if (afterCat.startsWith(sub) || afterCat.includes(sub)) {
                return { major: cat, minor: sub };
              }
            }
            // æ¨¡ç³ŠåŒ¹é…å°åˆ†ç±»
            if (afterCat.length >= 2) {
              const candidate = afterCat.substring(0, Math.min(6, afterCat.length));
              for (const sub of CATEGORY_TREE[cat]) {
                if (sub !== 'å…¶ä»–' && editDistance(candidate.substring(0, sub.length), sub) <= 1) {
                  return { major: cat, minor: sub };
                }
              }
            }
          }
        }
      }

      // ç­–ç•¥1ï¼šåŒ¹é… "å¤§åˆ†ç±» > å°åˆ†ç±»" æ ¼å¼ï¼ˆå¤šç§åˆ†éš”ç¬¦ï¼‰
      // æ‰©å±•åˆ†éš”ç¬¦ï¼š> ã€‹ â¤ â–¸ â–º â†’ - / | : ï¼‰ ) ] ã€‘åŠå…¶OCRå˜ä½“
      const sepPattern = /([\u4e00-\u9fa5A-Za-z]{2,8})\s*[>ã€‹â¤â–¸â–ºâ†’\-\/\|:ï¼š\)\ï¼‰\]ã€‘\.Â·,ï¼Œ;ï¼›\s]+\s*([\u4e00-\u9fa5A-Za-z]{2,8})/;
      for (const line of lines) {
        const match = line.match(sepPattern);
        if (match) {
          let major = match[1].trim();
          let minor = match[2].trim();
          if (isValidMajor(major)) {
            major = fixMajor(major);
            minor = fixMinor(major, minor);
            return { major, minor };
          }
          // ä¹Ÿè®¸OCRæŠŠå¤§å°åˆ†ç±»é¡ºåºåäº†ï¼Œæˆ–è€…åŒ¹é…åˆ°çš„ä¸æ˜¯å¤§åˆ†ç±»
          // å°è¯•æ£€æŸ¥minoræ˜¯å¦æ˜¯å¤§åˆ†ç±»
          if (isValidMajor(minor)) {
            const fixedMajor = fixMajor(minor);
            const fixedMinor = fixMinor(fixedMajor, major);
            return { major: fixedMajor, minor: fixedMinor };
          }
        }
      }

      // ç­–ç•¥1bï¼šä¹Ÿå¯¹åˆå¹¶åçš„æ•´è¡Œæ–‡æœ¬å°è¯•
      const matchFull = rawText.match(sepPattern);
      if (matchFull) {
        let major = matchFull[1].trim();
        let minor = matchFull[2].trim();
        if (isValidMajor(major)) {
          major = fixMajor(major);
          minor = fixMinor(major, minor);
          return { major, minor };
        }
      }

      // ç­–ç•¥2ï¼šåœ¨æ‰€æœ‰æ–‡æœ¬ä¸­ç›´æ¥æœç´¢å·²çŸ¥çš„å¤§åˆ†ç±»å
      const fullText = rawText.replace(/[^a-zA-Z\u4e00-\u9fa5\s]/g, ' ');
      for (const cat of MAJOR_CATEGORIES) {
        if (fullText.includes(cat)) {
          // åœ¨å¤§åˆ†ç±»åé¢æ‰¾å°åˆ†ç±»
          const afterIdx = fullText.indexOf(cat) + cat.length;
          const afterText = fullText.substring(afterIdx).trim();
          // ä¹Ÿçœ‹å¤§åˆ†ç±»å‰é¢çš„æ–‡æœ¬
          const beforeText = fullText.substring(0, fullText.indexOf(cat)).trim();
          // åœ¨å¤§åˆ†ç±»åé¢çš„æ–‡æœ¬ä¸­æœç´¢å·²çŸ¥å°åˆ†ç±»
          if (CATEGORY_TREE[cat]) {
            for (const sub of CATEGORY_TREE[cat]) {
              if (afterText.includes(sub)) {
                return { major: cat, minor: sub };
              }
            }
            // ä¹Ÿåœ¨å‰é¢çš„æ–‡æœ¬ä¸­æ‰¾å°åˆ†ç±»ï¼ˆOCRå¯èƒ½æŠŠé¡ºåºæåï¼‰
            for (const sub of CATEGORY_TREE[cat]) {
              if (beforeText.includes(sub)) {
                return { major: cat, minor: sub };
              }
            }
          }
          // å–ç¬¬ä¸€ä¸ª2-6å­—çš„è¯ä½œä¸ºå°åˆ†ç±»
          const firstWord = afterText.match(/[\u4e00-\u9fa5A-Za-z]{2,6}/);
          if (firstWord) {
            const minor = fixMinor(cat, firstWord[0]);
            return { major: cat, minor };
          }
          return { major: cat, minor: '' };
        }
      }

      // ç­–ç•¥3ï¼šæ¨¡ç³ŠåŒ¹é…å¤§åˆ†ç±»ï¼ˆOCRå¯èƒ½æœ‰é”™å­—ï¼‰
      const words = fullText.match(/[\u4e00-\u9fa5]{2,8}/g) || [];
      for (const word of words) {
        for (const cat of MAJOR_CATEGORIES) {
          const dist = editDistance(word, cat);
          if (dist <= 1 || (word.length >= 3 && cat.length >= 3 && dist <= 2)) {
            // æ‰¾åˆ°æ¨¡ç³ŠåŒ¹é…çš„å¤§åˆ†ç±»ï¼Œç»§ç»­æ‰¾å°åˆ†ç±»
            const fixedMajor = cat;
            const afterIdx = fullText.indexOf(word) + word.length;
            const afterText = fullText.substring(afterIdx).trim();
            if (CATEGORY_TREE[fixedMajor]) {
              for (const sub of CATEGORY_TREE[fixedMajor]) {
                if (afterText.includes(sub)) {
                  return { major: fixedMajor, minor: sub };
                }
              }
              // æ¨¡ç³ŠåŒ¹é…å°åˆ†ç±»
              const afterWords = afterText.match(/[\u4e00-\u9fa5A-Za-z]{2,6}/g) || [];
              for (const aw of afterWords) {
                for (const sub of CATEGORY_TREE[fixedMajor]) {
                  if (editDistance(aw, sub) <= 1) {
                    return { major: fixedMajor, minor: sub };
                  }
                }
              }
            }
            return { major: fixedMajor, minor: '' };
          }
        }
      }

      // ç­–ç•¥4ï¼šç›´æ¥æœç´¢å·²çŸ¥å°åˆ†ç±»åï¼Œåæ¨å¤§åˆ†ç±»
      for (const word of words) {
        for (const [sub, maj] of Object.entries(allMinors)) {
          if (sub === 'å…¶ä»–') continue;
          if (word === sub || (word.length >= 2 && editDistance(word, sub) <= 1)) {
            return { major: maj, minor: sub };
          }
        }
      }

      // ç­–ç•¥5ï¼šè‹±æ–‡è¯åŒ¹é…ï¼ˆæŸäº›åˆ†ç±»å«è‹±æ–‡ï¼‰
      const engWords = fullText.match(/[A-Za-z]{2,}/gi) || [];
      for (const ew of engWords) {
        for (const [sub, maj] of Object.entries(allMinors)) {
          if (sub === 'å…¶ä»–') continue;
          if (ew.toLowerCase() === sub.toLowerCase()) {
            return { major: maj, minor: sub };
          }
        }
      }

      return null;
    }

    // å¹¶è¡ŒOCRï¼šåç§° + åˆ†ç±»
    const ocrPromises = [];

    // OCR 1: è¯†åˆ«Appåç§°
    if (nameW > 10 && nameH > 5) {
      // å‡†å¤‡åŸå§‹å½©è‰²å›¾ç‰‡ï¼ˆä»…æ”¾å¤§ï¼Œä¸äºŒå€¼åŒ–ï¼‰ â€”â€” ç»™ OCR.space
      function prepareOriginalCanvas(srcX, srcY, srcW, srcH, scale) {
        const c = document.createElement('canvas');
        c.width = Math.round(srcW * scale);
        c.height = Math.round(srcH * scale);
        const cCtx = c.getContext('2d');
        cCtx.imageSmoothingEnabled = true;
        cCtx.imageSmoothingQuality = 'high';
        cCtx.fillStyle = '#ffffff';
        cCtx.fillRect(0, 0, c.width, c.height);
        cCtx.drawImage(cropImage, srcX, srcY, srcW, srcH, 0, 0, c.width, c.height);
        return c.toDataURL('image/png');
      }

      // å‡†å¤‡äºŒå€¼åŒ–å›¾ç‰‡ â€”â€” ç»™ Tesseract é™çº§ç”¨
      function prepareNameCanvas(srcX, srcY, srcW, srcH, scale, threshold) {
        const c = document.createElement('canvas');
        c.width = Math.round(srcW * scale);
        c.height = Math.round(srcH * scale);
        const cCtx = c.getContext('2d');
        cCtx.imageSmoothingEnabled = true;
        cCtx.imageSmoothingQuality = 'high';
        cCtx.fillStyle = '#ffffff';
        cCtx.fillRect(0, 0, c.width, c.height);
        cCtx.drawImage(cropImage, srcX, srcY, srcW, srcH, 0, 0, c.width, c.height);
        const imgData = cCtx.getImageData(0, 0, c.width, c.height);
        const pxData = imgData.data;
        for (let i = 0; i < pxData.length; i += 4) {
          const r = pxData[i], g = pxData[i+1], b = pxData[i+2];
          const gray = r * 0.299 + g * 0.587 + b * 0.114;
          const val = gray < threshold ? 0 : 255;
          pxData[i] = pxData[i+1] = pxData[i+2] = val;
        }
        cCtx.putImageData(imgData, 0, 0);
        return c.toDataURL('image/png');
      }

      const nameOriginal = prepareOriginalCanvas(nameX, nameY, nameW, nameH, 4);
      const nameProcessed = prepareNameCanvas(nameX, nameY, nameW, nameH, 4, 128);

      const nameOcrPromise = doOCR(nameOriginal, nameProcessed).then(text => {
        console.log('[åç§°OCRåŸå§‹æ–‡æœ¬]', text);

        if (!text) return { type: 'name', value: '' };

        // åå¤„ç†ï¼šå»åƒåœ¾å­—ç¬¦
        let cleaned = postProcessOcrText(text);
        
        const lines = cleaned.split('\n').map(l => l.trim()).filter(l => l);
        if (lines.length === 0) return { type: 'name', value: '' };
        
        let name = lines[0];
        // å¦‚æœç¬¬ä¸€è¡Œå¤ªçŸ­ï¼Œæ‹¼æ¥ç¬¬äºŒè¡Œ
        if (name.length <= 1 && lines.length > 1) {
          name = lines[0] + lines[1];
        }
        
        // é™åˆ¶é•¿åº¦
        if (name.length > 10) {
          const parts = name.split(/\s+/);
          name = parts[0];
        }
        if (name.length > 8) {
          name = name.substring(0, 8);
        }
        
        // ç”¨å·²çŸ¥Appåç§°çº é”™
        name = correctOcrName(name);
        
        return { type: 'name', value: name };
      }).catch(() => ({ type: 'name', value: '' }));

      ocrPromises.push(nameOcrPromise);
    }

    // OCR 2: è¯†åˆ«å³ä¾§åˆ†ç±»æ ‡ç­¾
    if (catW > 10 && catH > 5) {
      // åŸå§‹å½©è‰²å›¾ç‰‡ï¼ˆç»™ OCR.spaceï¼‰
      function prepareCatOriginal(srcX, srcY, srcW, srcH, scale) {
        const c = document.createElement('canvas');
        c.width = Math.round(srcW * scale);
        c.height = Math.round(srcH * scale);
        const cCtx = c.getContext('2d');
        cCtx.imageSmoothingEnabled = true;
        cCtx.imageSmoothingQuality = 'high';
        cCtx.fillStyle = '#ffffff';
        cCtx.fillRect(0, 0, c.width, c.height);
        cCtx.drawImage(cropImage, srcX, srcY, srcW, srcH, 0, 0, c.width, c.height);
        return c.toDataURL('image/png');
      }

      // äºŒå€¼åŒ–å›¾ç‰‡ï¼ˆç»™ Tesseract é™çº§ç”¨ï¼‰
      function prepareOcrCanvas(srcX, srcY, srcW, srcH, scale, threshold, detectBlue) {
        const c = document.createElement('canvas');
        c.width = Math.round(srcW * scale);
        c.height = Math.round(srcH * scale);
        const cCtx = c.getContext('2d');
        cCtx.imageSmoothingEnabled = true;
        cCtx.imageSmoothingQuality = 'high';
        cCtx.fillStyle = '#ffffff';
        cCtx.fillRect(0, 0, c.width, c.height);
        cCtx.drawImage(cropImage, srcX, srcY, srcW, srcH, 0, 0, c.width, c.height);
        const imgData = cCtx.getImageData(0, 0, c.width, c.height);
        const pxData = imgData.data;
        for (let i = 0; i < pxData.length; i += 4) {
          const r = pxData[i], g = pxData[i+1], b = pxData[i+2];
          const gray = r * 0.299 + g * 0.587 + b * 0.114;
          let isText = gray < threshold;
          if (detectBlue) {
            const isBlue = (b > 120 && b > r * 1.3 && b > g * 1.1);
            isText = isText || isBlue;
          }
          const isGrayText = (gray < 180 && Math.abs(r - g) < 30 && Math.abs(g - b) < 30 && Math.abs(r - b) < 30);
          isText = isText || (isGrayText && gray < threshold + 40);
          const val = isText ? 0 : 255;
          pxData[i] = pxData[i+1] = pxData[i+2] = val;
        }
        cCtx.putImageData(imgData, 0, 0);
        return c.toDataURL('image/png');
      }

      const catOriginal = prepareCatOriginal(catX, catY, catW, catH, 5);
      const catProcessed = prepareOcrCanvas(catX, catY, catW, catH, 5, 155, true);

      const catOcrPromise = doOCR(catOriginal, catProcessed).then(text => {
        console.log('[åˆ†ç±»OCRåŸå§‹æ–‡æœ¬]', text);
        
        if (!text) return { type: 'category', value: null };
        
        const cat = extractCategoryFromOcr(text);
        console.log('[åˆ†ç±»OCRæœ€ç»ˆç»“æœ]', cat);
        return { type: 'category', value: cat };
      }).catch((e) => { 
        console.warn('[åˆ†ç±»OCRå¤±è´¥]', e); 
        return { type: 'category', value: null }; 
      });

      ocrPromises.push(catOcrPromise);
    }

    if (ocrPromises.length > 0) {
      Promise.all(ocrPromises).then(results => {
        if (index >= cropItems.length) return;

        let name = '';
        let ocrCat = null;

        results.forEach(r => {
          if (r.type === 'name') name = r.value;
          if (r.type === 'category') ocrCat = r.value;
        });

        cropItems[index].name = name || 'æœªå‘½åLogo';

        // æ ¹æ®Appåç§°è‡ªåŠ¨çŒœæµ‹åœ°åŒºï¼ˆå¦‚æœçŒœåˆ°äº†å°±ç”¨çŒœæµ‹å€¼ï¼Œå¦åˆ™ç”¨æ‰¹é‡è®¾ç½®çš„åŒºåŸŸï¼‰
        const guessedRegion = guessRegionByName(name);
        cropItems[index].region = guessedRegion || currentRegion;

        // åˆ†ç±»ç­–ç•¥ï¼šä»…ä½¿ç”¨OCRè¯†åˆ«ç»“æœï¼Œä¸ç”¨æ˜ å°„è¡¨çŒœæµ‹ï¼ˆé¿å…"å¹»è§‰"ï¼‰
        // OCRæ²¡è¯†åˆ«åˆ°åˆ†ç±»æ—¶ç•™ç©ºï¼Œè®©ç”¨æˆ·æ‰‹åŠ¨é€‰æ‹©ï¼Œç»ä¸ç»™å‡ºå¯èƒ½é”™è¯¯çš„åˆ†ç±»
        if (ocrCat && ocrCat.major) {
          cropItems[index].category = ocrCat.major;
          cropItems[index].subcategory = ocrCat.minor || '';
        }

        cropItems[index].ocrDone = true;
        renderCropList();
      });
    } else {
      cropItems[index].name = 'æœªå‘½åLogo';
      cropItems[index].category = '';
      cropItems[index].subcategory = '';
      cropItems[index].ocrDone = true;
      renderCropList();
    }
  }

  function renderCropList() {
    cropCountEl.textContent = cropItems.length;
    cropList.innerHTML = '';
    cropItems.forEach((item, i) => {
      const div = document.createElement('div');
      div.className = 'crop-item';
      const statusHtml = item.ocrDone === false
        ? '<div class="ocr-status">æ­£åœ¨è¯†åˆ«...</div>'
        : '';
      const disabled = item.ocrDone === false ? 'disabled' : '';

      // å¤§åˆ†ç±»é€‰é¡¹
      let majorOptions = '<option value="">å¤§åˆ†ç±»</option>';
      MAJOR_CATEGORIES.forEach(cat => {
        const selected = item.category === cat ? 'selected' : '';
        majorOptions += `<option value="${cat}" ${selected}>${cat}</option>`;
      });

      // å°åˆ†ç±»é€‰é¡¹ï¼ˆåŸºäºå½“å‰å¤§åˆ†ç±»ï¼‰
      let minorOptions = '<option value="">å°åˆ†ç±»</option>';
      if (item.category && CATEGORY_TREE[item.category]) {
        CATEGORY_TREE[item.category].forEach(sub => {
          const selected = item.subcategory === sub ? 'selected' : '';
          minorOptions += `<option value="${sub}" ${selected}>${sub}</option>`;
        });
      }

      // åœ°åŒºé€‰é¡¹
      let regionOptions = '<option value="">åœ°åŒº</option>';
      REGIONS.forEach(r => {
        const selected = item.region === r ? 'selected' : '';
        regionOptions += `<option value="${r}" ${selected}>${r}</option>`;
      });

      div.innerHTML = `
        <img src="${item.src}" alt="logo">
        <div class="tag-group">
          <span class="tag-product">${item.product || ''}</span>
          ${item.region ? `<span class="tag-region">${item.region}</span>` : ''}
        </div>
        <input type="text" value="${item.name}" placeholder="Logo åç§°" data-index="${i}" data-field="name" ${disabled}>
        <div class="category-group">
          <select data-index="${i}" data-field="category" ${disabled}>${majorOptions}</select>
          <select data-index="${i}" data-field="subcategory" ${disabled}>${minorOptions}</select>
        </div>
        <select class="region-select" data-index="${i}" data-field="region" ${disabled}>${regionOptions}</select>
        ${statusHtml}
        <div class="crop-item-actions">
          <button class="remove-crop" data-index="${i}">åˆ é™¤</button>
        </div>
      `;
      cropList.appendChild(div);
    });

    cropList.querySelectorAll('input').forEach(el => {
      el.addEventListener('input', (e) => {
        const idx = e.target.dataset.index;
        cropItems[idx].name = e.target.value;
        // è‡ªåŠ¨æ›´æ–°åœ°åŒºçŒœæµ‹
        const guessedRegion = guessRegionByName(e.target.value);
        if (guessedRegion) cropItems[idx].region = guessedRegion;
        const matched = matchCategory(e.target.value);
        if (matched.major) {
          cropItems[idx].category = matched.major;
          cropItems[idx].subcategory = matched.minor;
        }
        renderCropList();
      });
    });
    cropList.querySelectorAll('select[data-field="category"]').forEach(el => {
      el.addEventListener('change', (e) => {
        const idx = e.target.dataset.index;
        cropItems[idx].category = e.target.value;
        cropItems[idx].subcategory = '';
        renderCropList();
      });
    });
    cropList.querySelectorAll('select[data-field="subcategory"]').forEach(el => {
      el.addEventListener('change', (e) => {
        const idx = e.target.dataset.index;
        cropItems[idx].subcategory = e.target.value;
      });
    });
    cropList.querySelectorAll('select[data-field="region"]').forEach(el => {
      el.addEventListener('change', (e) => {
        const idx = e.target.dataset.index;
        cropItems[idx].region = e.target.value;
      });
    });
    cropList.querySelectorAll('.remove-crop').forEach(btn => {
      btn.addEventListener('click', (e) => {
        cropItems.splice(e.target.dataset.index, 1);
        renderCropList();
        updateGenerateBar();
      });
    });
  }

  // ============ æ¨¡å¼äºŒï¼šç›´æ¥ä¸Šä¼  ============
  const directUploadArea = document.getElementById('directUploadArea');
  const directFileInput = document.getElementById('directFileInput');
  const directGrid = document.getElementById('directGrid');
  let directItems = [];

  directUploadArea.addEventListener('click', () => directFileInput.click());
  setupDragDrop(directUploadArea, directFileInput);

  directFileInput.addEventListener('change', (e) => {
    handleDirectFiles(e.target.files);
    e.target.value = '';
  });

  function handleDirectFiles(files) {
    Array.from(files).filter(f => f.type.startsWith('image/')).forEach(file => {
      const reader = new FileReader();
      reader.onload = (e) => {
        const name = file.name.replace(/\.[^/.]+$/, '');
        directItems.push({ src: e.target.result, name, product: currentProduct, region: guessRegionByName(name) || currentRegion });
        renderDirectGrid();
        updateGenerateBar();
      };
      reader.readAsDataURL(file);
    });
  }

  function renderDirectGrid() {
    directGrid.innerHTML = '';
    directItems.forEach((item, i) => {
      const div = document.createElement('div');
      div.className = 'direct-item';

      let regionOptions = '<option value="">åœ°åŒº</option>';
      REGIONS.forEach(r => {
        const selected = item.region === r ? 'selected' : '';
        regionOptions += `<option value="${r}" ${selected}>${r}</option>`;
      });

      div.innerHTML = `
        <img src="${item.src}" alt="logo">
        <div class="tag-group">
          <span class="tag-product">${item.product || ''}</span>
          ${item.region ? `<span class="tag-region">${item.region}</span>` : ''}
        </div>
        <input type="text" value="${item.name}" placeholder="Logo åç§°" data-index="${i}">
        <select class="region-select" data-index="${i}" data-field="region" style="width:100%;padding:5px 8px;border:1px solid #ddd;border-radius:6px;font-size:0.78rem;margin-top:4px;">${regionOptions}</select>
        <button class="remove-direct" data-index="${i}">åˆ é™¤</button>
      `;
      directGrid.appendChild(div);
    });

    directGrid.querySelectorAll('input').forEach(input => {
      input.addEventListener('input', (e) => {
        const idx = e.target.dataset.index;
        directItems[idx].name = e.target.value;
        const guessedRegion = guessRegionByName(e.target.value);
        if (guessedRegion) directItems[idx].region = guessedRegion;
        renderDirectGrid();
      });
    });
    directGrid.querySelectorAll('select[data-field="region"]').forEach(el => {
      el.addEventListener('change', (e) => {
        directItems[e.target.dataset.index].region = e.target.value;
      });
    });
    directGrid.querySelectorAll('.remove-direct').forEach(btn => {
      btn.addEventListener('click', (e) => {
        directItems.splice(e.target.dataset.index, 1);
        renderDirectGrid();
        updateGenerateBar();
      });
    });
  }

  // ============ ç”Ÿæˆ / æ¸…ç©º ============
  const generateBar = document.getElementById('generateBar');
  const generateBtn = document.getElementById('generateBtn');
  const clearAllBtn = document.getElementById('clearAllBtn');
  const wallSection = document.getElementById('wallSection');

  function updateGenerateBar() {
    const count = cropItems.length + directItems.length;
    generateBar.classList.toggle('visible', count > 0);
  }

  generateBtn.addEventListener('click', () => {
    logoEntries = [...cropItems, ...directItems];
    if (logoEntries.length === 0) return;
    // è‡ªåŠ¨å­˜å…¥ Logo åº“
    addToLibrary(logoEntries);
    renderWall();
    wallSection.classList.add('visible');
    wallSection.scrollIntoView({ behavior: 'smooth' });
  });

  // ä»…å­˜å…¥ Logo åº“ï¼ˆä¸ç”Ÿæˆå¢™ï¼‰
  document.getElementById('saveToLibBtn').addEventListener('click', () => {
    const items = [...cropItems, ...directItems];
    if (items.length === 0) return;
    addToLibrary(items);
    alert(`å·²å°† ${items.length} ä¸ª Logo å­˜å…¥åº“ä¸­ï¼`);
    // åˆ‡æ¢åˆ°åº“ tab
    document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
    document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
    document.querySelector('[data-tab="library"]').classList.add('active');
    document.getElementById('tab-library').classList.add('active');
  });

  clearAllBtn.addEventListener('click', () => {
    if (!confirm('ç¡®å®šæ¸…ç©ºå…¨éƒ¨ Logo å—ï¼Ÿ')) return;
    cropItems = [];
    directItems = [];
    renderCropList();
    renderDirectGrid();
    updateGenerateBar();
    wallSection.classList.remove('visible');
  });

  document.getElementById('backEditBtn').addEventListener('click', () => {
    wallSection.classList.remove('visible');
  });

  // ============ Logo å¢™æ¸²æŸ“ ============
  const logoWall = document.getElementById('logoWall');
  const wallLayout = document.getElementById('wallLayout');
  const wallSize = document.getElementById('wallSize');
  const wallGap = document.getElementById('wallGap');
  const wallBg = document.getElementById('wallBg');
  const wallGrayscale = document.getElementById('wallGrayscale');
  const wallHideNames = document.getElementById('wallHideNames');

  function renderWall() {
    const size = wallSize.value + 'px';
    const gap = wallGap.value + 'px';
    const layout = wallLayout.value;

    logoWall.innerHTML = '';
    logoWall.className = 'logo-wall';

    if (layout === 'grid') {
      logoWall.style.display = 'grid';
      logoWall.style.gridTemplateColumns = `repeat(auto-fill, minmax(${parseInt(wallSize.value) + 60}px, 1fr))`;
      logoWall.style.gap = gap;
      logoWall.style.flexWrap = '';
      logoWall.style.justifyContent = '';
    } else {
      logoWall.classList.add('layout-flex');
      logoWall.style.display = 'flex';
      logoWall.style.gap = gap;
      logoWall.style.gridTemplateColumns = '';
    }

    logoWall.style.backgroundColor = wallBg.value;

    if (wallGrayscale.checked) logoWall.classList.add('grayscale');
    if (wallHideNames.checked) logoWall.classList.add('hide-names');

    logoEntries.forEach(entry => {
      const div = document.createElement('div');
      div.className = 'logo-entry';

      const img = document.createElement('img');
      img.src = entry.src;
      img.alt = entry.name;
      img.style.width = size;
      img.style.height = size;

      const nameEl = document.createElement('div');
      nameEl.className = 'logo-name';
      nameEl.textContent = entry.name;
      nameEl.style.maxWidth = parseInt(wallSize.value) + 40 + 'px';

      div.appendChild(img);
      div.appendChild(nameEl);

      // äº§å“å’Œåœ°åŒºæ ‡ç­¾
      if (entry.product || entry.region) {
        const tagDiv = document.createElement('div');
        tagDiv.className = 'tag-group';
        if (entry.product) tagDiv.innerHTML += `<span class="tag-product">${entry.product}</span>`;
        if (entry.region) tagDiv.innerHTML += `<span class="tag-region">${entry.region}</span>`;
        div.appendChild(tagDiv);
      }

      if (entry.category) {
        const catEl = document.createElement('div');
        catEl.className = 'logo-category';
        catEl.textContent = entry.category;
        catEl.style.maxWidth = parseInt(wallSize.value) + 40 + 'px';
        div.appendChild(catEl);
      }
      if (entry.subcategory) {
        const subEl = document.createElement('div');
        subEl.className = 'logo-subcategory';
        subEl.textContent = entry.subcategory;
        subEl.style.maxWidth = parseInt(wallSize.value) + 40 + 'px';
        div.appendChild(subEl);
      }

      logoWall.appendChild(div);
    });
  }

  wallLayout.addEventListener('change', renderWall);
  wallSize.addEventListener('input', renderWall);
  wallGap.addEventListener('input', renderWall);
  wallBg.addEventListener('input', () => { logoWall.style.backgroundColor = wallBg.value; });
  wallGrayscale.addEventListener('change', () => {
    logoWall.classList.toggle('grayscale', wallGrayscale.checked);
  });
  wallHideNames.addEventListener('change', () => {
    logoWall.classList.toggle('hide-names', wallHideNames.checked);
  });

  // ============ å¯¼å‡º ============
  document.getElementById('exportBtn').addEventListener('click', () => {
    const btn = document.getElementById('exportBtn');
    btn.textContent = 'å¯¼å‡ºä¸­...';
    btn.disabled = true;

    const wrapper = document.getElementById('wallWrapper');
    const rect = wrapper.getBoundingClientRect();
    const scale = 2;
    const canvas = document.createElement('canvas');
    canvas.width = rect.width * scale;
    canvas.height = rect.height * scale;
    const ctx = canvas.getContext('2d');
    ctx.scale(scale, scale);
    ctx.fillStyle = wallBg.value;
    ctx.fillRect(0, 0, rect.width, rect.height);

    const entries = document.querySelectorAll('.logo-entry');
    let loaded = 0;
    const total = entries.length;

    if (total === 0) {
      btn.textContent = 'å¯¼å‡ºå›¾ç‰‡';
      btn.disabled = false;
      return;
    }

    entries.forEach(entry => {
      const img = entry.querySelector('img');
      const nameEl = entry.querySelector('.logo-name');
      const imgRect = img.getBoundingClientRect();
      const nameRect = nameEl ? nameEl.getBoundingClientRect() : null;

      const image = new Image();
      image.onload = () => {
        let dx = imgRect.left - rect.left;
        let dy = imgRect.top - rect.top;

        if (wallGrayscale.checked) {
          const tc = document.createElement('canvas');
          tc.width = imgRect.width * scale;
          tc.height = imgRect.height * scale;
          const tctx = tc.getContext('2d');
          tctx.scale(scale, scale);
          tctx.filter = 'grayscale(100%)';
          tctx.drawImage(image, 0, 0, imgRect.width, imgRect.height);
          ctx.drawImage(tc, dx, dy, imgRect.width, imgRect.height);
        } else {
          ctx.drawImage(image, dx, dy, imgRect.width, imgRect.height);
        }

        if (nameEl && !wallHideNames.checked) {
          const style = getComputedStyle(nameEl);
          ctx.font = `${style.fontWeight} ${style.fontSize} ${style.fontFamily}`;
          ctx.fillStyle = style.color;
          ctx.textAlign = 'center';
          const nx = nameRect.left - rect.left + nameRect.width / 2;
          const ny = nameRect.top - rect.top + parseInt(style.fontSize);
          ctx.fillText(nameEl.textContent, nx, ny);
        }

        loaded++;
        if (loaded === total) {
          const link = document.createElement('a');
          link.download = 'logo-wall.png';
          link.href = canvas.toDataURL('image/png');
          link.click();
          btn.textContent = 'å¯¼å‡ºå›¾ç‰‡';
          btn.disabled = false;
        }
      };
      image.src = img.src;
    });
  });

  // ============ å¯¼å‡º Excelï¼ˆå¸¦Logoå›¾ç‰‡ï¼‰ ============
  async function doExportExcel(items, btnEl) {
    if (!items || items.length === 0) {
      alert('æ²¡æœ‰å¯å¯¼å‡ºçš„æ•°æ®');
      return;
    }

    const origText = btnEl.textContent;
    btnEl.textContent = 'å¯¼å‡ºä¸­...';
    btnEl.disabled = true;

    try {
      const wb = new ExcelJS.Workbook();
      const ws = wb.addWorksheet('Logoåˆ—è¡¨');

      // åˆ—å®½
      ws.columns = [
        { header: 'Logo', key: 'logo', width: 12 },
        { header: 'åº”ç”¨åç§°', key: 'name', width: 20 },
        { header: 'äº§å“', key: 'product', width: 10 },
        { header: 'åœ°åŒº', key: 'region', width: 14 },
        { header: 'å¤§åˆ†ç±»', key: 'major', width: 16 },
        { header: 'å°åˆ†ç±»', key: 'minor', width: 16 },
      ];

      // è¡¨å¤´æ ·å¼
      const headerRow = ws.getRow(1);
      headerRow.height = 24;
      headerRow.eachCell(cell => {
        cell.font = { bold: true, color: { argb: 'FFFFFFFF' }, size: 12 };
        cell.fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FF667EEA' } };
        cell.alignment = { horizontal: 'center', vertical: 'middle' };
        cell.border = { bottom: { style: 'thin', color: { argb: 'FF999999' } } };
      });

      // æ•°æ®è¡Œ
      for (let i = 0; i < items.length; i++) {
        const entry = items[i];
        const rowIdx = i + 2;
        const row = ws.addRow(['', entry.name || '', entry.product || '', entry.region || '', entry.category || '', entry.subcategory || '']);
        row.height = 55;
        row.eachCell(cell => {
          cell.alignment = { horizontal: 'center', vertical: 'middle' };
          cell.border = {
            bottom: { style: 'thin', color: { argb: 'FFDDDDDD' } },
          };
        });

        // æ’å…¥Logoå›¾ç‰‡
        if (entry.src && entry.src.startsWith('data:image')) {
          const base64Data = entry.src.split(',')[1];
          const ext = entry.src.includes('image/png') ? 'png' : 'jpeg';
          const imageId = wb.addImage({
            base64: base64Data,
            extension: ext,
          });
          ws.addImage(imageId, {
            tl: { col: 0.15, row: rowIdx - 1 + 0.1 },
            ext: { width: 50, height: 50 },
          });
        }
      }

      // ç”Ÿæˆå¹¶ä¸‹è½½
      const buffer = await wb.xlsx.writeBuffer();
      const blob = new Blob([buffer], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
      saveAs(blob, 'logo-wall.xlsx');
    } catch (err) {
      console.error('Excelå¯¼å‡ºå¤±è´¥:', err);
      alert('å¯¼å‡ºå¤±è´¥ï¼Œè¯·é‡è¯•');
    }

    btnEl.textContent = origText;
    btnEl.disabled = false;
  }

  // Logoå¢™å·¥å…·æ çš„å¯¼å‡ºæŒ‰é’®
  document.getElementById('exportExcelBtn').addEventListener('click', () => {
    doExportExcel(logoEntries, document.getElementById('exportExcelBtn'));
  });

  // è£å‰ªåŒºæŒ‰é’®æ çš„å¯¼å‡ºæŒ‰é’®ï¼ˆç›´æ¥ä»cropItems+directItemså¯¼å‡ºï¼‰
  document.getElementById('exportExcelBarBtn').addEventListener('click', () => {
    const items = [...cropItems, ...directItems];
    doExportExcel(items, document.getElementById('exportExcelBarBtn'));
  });

  // ============ å¯¼å‡º PPTï¼ˆLogoå¢™å±•ç¤ºï¼‰ ============
  async function doExportPpt(items, btnEl) {
    if (!items || items.length === 0) {
      alert('æ²¡æœ‰å¯å¯¼å‡ºçš„æ•°æ®');
      return;
    }

    const origText = btnEl.textContent;
    btnEl.textContent = 'å¯¼å‡ºä¸­...';
    btnEl.disabled = true;

    try {
      const pptx = new PptxGenJS();
      pptx.layout = 'LAYOUT_WIDE'; // 16:9 å®½å±
      pptx.author = 'Logoå¢™ç”Ÿæˆå™¨';
      pptx.title = 'Logo å¢™';

      // æŒ‰åˆ†ç±»åˆ†ç»„
      const grouped = {};
      items.forEach(item => {
        const key = item.category || 'æœªåˆ†ç±»';
        if (!grouped[key]) grouped[key] = [];
        grouped[key].push(item);
      });

      // å°é¢é¡µ
      const coverSlide = pptx.addSlide();
      coverSlide.background = { fill: '667EEA' };
      coverSlide.addText('Logo å¢™', {
        x: 0.5, y: 1.5, w: '90%', h: 1.2,
        fontSize: 44, fontFace: 'Microsoft YaHei',
        color: 'FFFFFF', bold: true, align: 'center'
      });
      const productLabel = currentProduct || 'IM';
      const regionLabel = currentRegion || '';
      const subtitle = `äº§å“ï¼š${productLabel}` + (regionLabel ? `ã€€|ã€€åŒºåŸŸï¼š${regionLabel}` : '') + `ã€€|ã€€å…± ${items.length} ä¸ª Logo`;
      coverSlide.addText(subtitle, {
        x: 0.5, y: 2.8, w: '90%', h: 0.6,
        fontSize: 18, fontFace: 'Microsoft YaHei',
        color: 'DDDDFF', align: 'center'
      });
      const dateStr = new Date().toLocaleDateString('zh-CN', { year: 'numeric', month: 'long', day: 'numeric' });
      coverSlide.addText(dateStr, {
        x: 0.5, y: 3.5, w: '90%', h: 0.4,
        fontSize: 14, fontFace: 'Microsoft YaHei',
        color: 'BBBBEE', align: 'center'
      });

      // æ€»è§ˆé¡µï¼šæ‰€æœ‰Logoå¢™
      const COLS = 8;
      const LOGO_SIZE = 0.75; // è‹±å¯¸
      const GAP_X = 0.4;
      const GAP_Y = 0.45;
      const START_X = 0.5;
      const START_Y = 1.0;
      const ROWS_PER_SLIDE = 5;

      // å…¨éƒ¨Logoæ¦‚è§ˆé¡µï¼ˆå¯èƒ½å¤šé¡µï¼‰
      for (let page = 0; page * COLS * ROWS_PER_SLIDE < items.length; page++) {
        const slide = pptx.addSlide();
        slide.background = { fill: 'FFFFFF' };
        slide.addText('Logo æ€»è§ˆ', {
          x: 0.3, y: 0.15, w: '95%', h: 0.6,
          fontSize: 24, fontFace: 'Microsoft YaHei',
          color: '333333', bold: true
        });
        if (items.length > COLS * ROWS_PER_SLIDE) {
          slide.addText(`ç¬¬ ${page + 1} é¡µ`, {
            x: 10, y: 0.2, w: 2.5, h: 0.4,
            fontSize: 12, fontFace: 'Microsoft YaHei',
            color: '999999', align: 'right'
          });
        }

        const startIdx = page * COLS * ROWS_PER_SLIDE;
        const endIdx = Math.min(startIdx + COLS * ROWS_PER_SLIDE, items.length);

        for (let i = startIdx; i < endIdx; i++) {
          const idx = i - startIdx;
          const col = idx % COLS;
          const row = Math.floor(idx / COLS);
          const x = START_X + col * (LOGO_SIZE + GAP_X);
          const y = START_Y + row * (LOGO_SIZE + GAP_Y + 0.35);

          const entry = items[i];

          // æ·»åŠ Logoå›¾ç‰‡
          if (entry.src && entry.src.startsWith('data:image')) {
            slide.addImage({
              data: entry.src,
              x: x + (LOGO_SIZE - 0.65) / 2,
              y: y,
              w: 0.65,
              h: 0.65,
              rounding: true,
            });
          }

          // åç§°
          slide.addText(entry.name || '', {
            x: x - 0.1, y: y + 0.68, w: LOGO_SIZE + 0.2, h: 0.28,
            fontSize: 7, fontFace: 'Microsoft YaHei',
            color: '555555', align: 'center', valign: 'top',
            wrap: false
          });
        }
      }

      // æŒ‰åˆ†ç±»ç”Ÿæˆè¯¦æƒ…é¡µ
      const catKeys = Object.keys(grouped).sort((a, b) => {
        if (a === 'æœªåˆ†ç±»') return 1;
        if (b === 'æœªåˆ†ç±»') return -1;
        return grouped[b].length - grouped[a].length;
      });

      for (const cat of catKeys) {
        const catItems = grouped[cat];
        const catSlide = pptx.addSlide();
        catSlide.background = { fill: 'FAFBFC' };

        // åˆ†ç±»æ ‡é¢˜
        catSlide.addShape(pptx.shapes.RECTANGLE, {
          x: 0, y: 0, w: '100%', h: 0.8,
          fill: { color: '667EEA' }
        });
        catSlide.addText(`${cat}ï¼ˆ${catItems.length}ï¼‰`, {
          x: 0.4, y: 0.1, w: 8, h: 0.6,
          fontSize: 22, fontFace: 'Microsoft YaHei',
          color: 'FFFFFF', bold: true
        });

        // Logoåˆ—è¡¨ï¼ˆè¡¨æ ¼å½¢å¼ï¼‰
        const tableRows = [
          [
            { text: 'Logo', options: { bold: true, color: 'FFFFFF', fill: { color: '667EEA' }, align: 'center', fontSize: 10 } },
            { text: 'åº”ç”¨åç§°', options: { bold: true, color: 'FFFFFF', fill: { color: '667EEA' }, align: 'center', fontSize: 10 } },
            { text: 'äº§å“', options: { bold: true, color: 'FFFFFF', fill: { color: '667EEA' }, align: 'center', fontSize: 10 } },
            { text: 'åŒºåŸŸ', options: { bold: true, color: 'FFFFFF', fill: { color: '667EEA' }, align: 'center', fontSize: 10 } },
            { text: 'å¤§åˆ†ç±»', options: { bold: true, color: 'FFFFFF', fill: { color: '667EEA' }, align: 'center', fontSize: 10 } },
            { text: 'å°åˆ†ç±»', options: { bold: true, color: 'FFFFFF', fill: { color: '667EEA' }, align: 'center', fontSize: 10 } }
          ]
        ];

        const maxPerPage = 10;
        const pageItems = catItems.slice(0, maxPerPage);

        pageItems.forEach(entry => {
          tableRows.push([
            { text: '', options: { align: 'center', fontSize: 9 } },
            { text: entry.name || '', options: { align: 'center', fontSize: 9 } },
            { text: entry.product || '', options: { align: 'center', fontSize: 9, color: '667EEA' } },
            { text: entry.region || '', options: { align: 'center', fontSize: 9, color: '389E0D' } },
            { text: entry.category || '', options: { align: 'center', fontSize: 9 } },
            { text: entry.subcategory || '', options: { align: 'center', fontSize: 9 } }
          ]);
        });

        catSlide.addTable(tableRows, {
          x: 0.3, y: 1.0, w: 12.5,
          colW: [1.2, 2.5, 1.5, 1.8, 2.5, 2.5],
          rowH: 0.45,
          border: { type: 'solid', pt: 0.5, color: 'DDDDDD' },
          autoPage: false
        });

        // åœ¨è¡¨æ ¼ä¸Šå åŠ Logoå›¾ç‰‡
        pageItems.forEach((entry, i) => {
          if (entry.src && entry.src.startsWith('data:image')) {
            catSlide.addImage({
              data: entry.src,
              x: 0.5,
              y: 1.0 + 0.45 + i * 0.45 + 0.03,
              w: 0.35,
              h: 0.35,
              rounding: true
            });
          }
        });

        // å¤šä½™Logoæç¤º
        if (catItems.length > maxPerPage) {
          catSlide.addText(`...åŠå…¶ä»– ${catItems.length - maxPerPage} ä¸ª`, {
            x: 0.3, y: 6.8, w: 5, h: 0.3,
            fontSize: 10, fontFace: 'Microsoft YaHei',
            color: '999999', italic: true
          });
        }
      }

      // å¯¼å‡º
      const pptData = await pptx.write({ outputType: 'blob' });
      saveAs(pptData, 'logo-wall.pptx');
    } catch (err) {
      console.error('PPTå¯¼å‡ºå¤±è´¥:', err);
      alert('PPTå¯¼å‡ºå¤±è´¥ï¼Œè¯·é‡è¯•');
    }

    btnEl.textContent = origText;
    btnEl.disabled = false;
  }

  // PPTå¯¼å‡ºæŒ‰é’®ç»‘å®š
  document.getElementById('exportPptBtn').addEventListener('click', () => {
    doExportPpt(logoEntries, document.getElementById('exportPptBtn'));
  });
  document.getElementById('exportPptBarBtn').addEventListener('click', () => {
    const items = [...cropItems, ...directItems];
    doExportPpt(items, document.getElementById('exportPptBarBtn'));
  });

  // ============ æ‹–æ‹½é€šç”¨ ============
  function setupDragDrop(area, input) {
    area.addEventListener('dragover', (e) => {
      e.preventDefault();
      area.classList.add('dragover');
    });
    area.addEventListener('dragleave', () => area.classList.remove('dragover'));
    area.addEventListener('drop', (e) => {
      e.preventDefault();
      area.classList.remove('dragover');
      if (input === cropFileInput && e.dataTransfer.files[0]) {
        loadCropImage(e.dataTransfer.files[0]);
      } else if (input === directFileInput) {
        handleDirectFiles(e.dataTransfer.files);
      }
    });
  }

  // ============ Logo åº“ UI ============
  const libraryGrid = document.getElementById('libraryGrid');
  const libraryFilter = document.getElementById('libraryFilter');
  const libraryCountEl = document.getElementById('libraryCount');
  let librarySelectedIds = new Set();
  let libraryCurrentCategory = 'all';

  function renderLibrary() {
    const lib = loadLibrary();
    libraryCountEl.textContent = lib.length;

    // è®¡ç®—æ¯ä¸ªç±»åˆ«çš„æ•°é‡
    const catCounts = {};
    lib.forEach(item => {
      const cat = item.category || 'æœªåˆ†ç±»';
      catCounts[cat] = (catCounts[cat] || 0) + 1;
    });

    // æ¸²æŸ“æ ‡ç­¾ç­›é€‰å™¨
    libraryFilter.innerHTML = '';
    const allTag = document.createElement('span');
    allTag.className = 'filter-tag' + (libraryCurrentCategory === 'all' ? ' active' : '');
    allTag.dataset.category = 'all';
    allTag.innerHTML = `å…¨éƒ¨<span class="tag-count">(${lib.length})</span>`;
    allTag.addEventListener('click', () => { libraryCurrentCategory = 'all'; renderLibrary(); });
    libraryFilter.appendChild(allTag);

    // æŒ‰æ•°é‡æ’åºç±»åˆ«
    const sortedCats = Object.entries(catCounts).sort((a, b) => b[1] - a[1]);
    sortedCats.forEach(([cat, count]) => {
      const tag = document.createElement('span');
      tag.className = 'filter-tag' + (libraryCurrentCategory === cat ? ' active' : '');
      tag.dataset.category = cat;
      tag.innerHTML = `${cat}<span class="tag-count">(${count})</span>`;
      tag.addEventListener('click', () => { libraryCurrentCategory = cat; renderLibrary(); });
      libraryFilter.appendChild(tag);
    });

    // ç­›é€‰
    let filtered = lib;
    if (libraryCurrentCategory !== 'all') {
      filtered = lib.filter(item => (item.category || 'æœªåˆ†ç±»') === libraryCurrentCategory);
    }

    // æ¸²æŸ“ç½‘æ ¼
    libraryGrid.innerHTML = '';
    if (filtered.length === 0) {
      libraryGrid.innerHTML = '<div class="library-empty">' +
        (lib.length === 0 ? 'Logo åº“ä¸ºç©ºï¼Œå»è£å‰ªæˆ–ä¸Šä¼  Logo å§' : 'è¯¥ç±»åˆ«ä¸‹æš‚æ—  Logo') +
        '</div>';
      return;
    }

    // æ¸…ç†ä¸å­˜åœ¨çš„é€‰ä¸­é¡¹
    librarySelectedIds = new Set([...librarySelectedIds].filter(id => lib.some(l => l.id === id)));

    filtered.forEach(item => {
      const div = document.createElement('div');
      div.className = 'library-item' + (librarySelectedIds.has(item.id) ? ' selected' : '');
      div.dataset.id = item.id;
      div.innerHTML = `
        <div class="lib-check">âœ“</div>
        <img src="${item.src}" alt="${item.name}">
        <div class="lib-name">${item.name}</div>
        ${item.category ? `<div class="lib-cat">${item.category}${item.subcategory ? ' > ' + item.subcategory : ''}</div>` : ''}
      `;
      div.addEventListener('click', () => {
        if (librarySelectedIds.has(item.id)) {
          librarySelectedIds.delete(item.id);
          div.classList.remove('selected');
        } else {
          librarySelectedIds.add(item.id);
          div.classList.add('selected');
        }
        updateLibraryBtnState();
      });
      libraryGrid.appendChild(div);
    });

    updateLibraryBtnState();
  }

  function updateLibraryBtnState() {
    const btn = document.getElementById('libraryGenerateBtn');
    const count = librarySelectedIds.size;
    btn.textContent = count > 0 ? `ç”¨é€‰ä¸­ ${count} é¡¹ç”Ÿæˆ Logo å¢™` : 'ç”¨é€‰ä¸­é¡¹ç”Ÿæˆ Logo å¢™';
    btn.disabled = count === 0;
    btn.style.opacity = count > 0 ? '1' : '0.5';
  }

  // å…¨é€‰
  document.getElementById('librarySelectAllBtn').addEventListener('click', () => {
    const lib = loadLibrary();
    let filtered = lib;
    if (libraryCurrentCategory !== 'all') {
      filtered = lib.filter(item => (item.category || 'æœªåˆ†ç±»') === libraryCurrentCategory);
    }
    const allSelected = filtered.every(item => librarySelectedIds.has(item.id));
    if (allSelected) {
      filtered.forEach(item => librarySelectedIds.delete(item.id));
    } else {
      filtered.forEach(item => librarySelectedIds.add(item.id));
    }
    renderLibrary();
  });

  // åˆ é™¤é€‰ä¸­
  document.getElementById('libraryDeleteSelectedBtn').addEventListener('click', () => {
    if (librarySelectedIds.size === 0) { alert('è¯·å…ˆé€‰æ‹©è¦åˆ é™¤çš„ Logo'); return; }
    if (!confirm(`ç¡®å®šåˆ é™¤é€‰ä¸­çš„ ${librarySelectedIds.size} ä¸ª Logo å—ï¼Ÿ`)) return;
    removeFromLibrary([...librarySelectedIds]);
    librarySelectedIds.clear();
  });

  // ç”¨é€‰ä¸­é¡¹ç”Ÿæˆ Logo å¢™
  document.getElementById('libraryGenerateBtn').addEventListener('click', () => {
    if (librarySelectedIds.size === 0) { alert('è¯·å…ˆé€‰æ‹© Logo'); return; }
    const lib = loadLibrary();
    logoEntries = lib.filter(item => librarySelectedIds.has(item.id));
    renderWall();
    wallSection.classList.add('visible');
    wallSection.scrollIntoView({ behavior: 'smooth' });
  });

  // ============ JSON å¯¼å…¥åŠŸèƒ½ï¼ˆé…åˆ Chrome æ’ä»¶ä½¿ç”¨ï¼‰ ============
  const jsonImportInput = document.getElementById('jsonImportInput');
  document.getElementById('libraryImportJsonBtn').addEventListener('click', () => {
    jsonImportInput.click();
  });

  jsonImportInput.addEventListener('change', (e) => {
    const file = e.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = (ev) => {
      try {
        let data = JSON.parse(ev.target.result);
        if (!Array.isArray(data)) {
          alert('JSON æ ¼å¼é”™è¯¯ï¼šåº”ä¸ºæ•°ç»„');
          return;
        }
        // å…¼å®¹æ’ä»¶å¯¼å‡ºæ ¼å¼å’Œæ ‡å‡†æ ¼å¼
        const items = data.map(item => ({
          src: item.src || '',
          name: item.name || 'æœªå‘½å',
          category: item.category || '',
          subcategory: item.subcategory || '',
          product: item.product || '',
          region: item.region || ''
        })).filter(item => item.src); // è¿‡æ»¤æ— å›¾ç‰‡çš„

        if (items.length === 0) {
          alert('æœªæ‰¾åˆ°æœ‰æ•ˆçš„ Logo æ•°æ®');
          return;
        }
        addToLibrary(items);
        alert(`âœ… æˆåŠŸå¯¼å…¥ ${items.length} ä¸ª Logo åˆ°åº“ä¸­ï¼`);
      } catch (err) {
        alert('JSON è§£æå¤±è´¥: ' + err.message);
      }
    };
    reader.readAsText(file);
    jsonImportInput.value = ''; // é‡ç½®
  });

  // é¡µé¢åŠ è½½æ—¶åˆå§‹åŒ–åº“
  renderLibrary();
</script>

</body>
</html>
